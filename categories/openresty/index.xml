<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>OpenResty on 做一个善于思考的学习者</title>
    <link>https://idevz.github.io/categories/openresty/</link>
    <description>Recent content in OpenResty on 做一个善于思考的学习者</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <copyright>© 2020 idevz.org</copyright>
    <lastBuildDate>Sat, 05 Aug 2017 21:48:09 +0800</lastBuildDate>
    
	<atom:link href="https://idevz.github.io/categories/openresty/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>data sharing</title>
      <link>https://idevz.github.io/2017/08/data-sharing/</link>
      <pubDate>Sat, 05 Aug 2017 21:48:09 +0800</pubDate>
      
      <guid>https://idevz.github.io/2017/08/data-sharing/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Lua 源码读书笔记</title>
      <link>https://idevz.github.io/2017/08/lua-%E6%BA%90%E7%A0%81%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 05 Aug 2017 21:28:55 +0800</pubDate>
      
      <guid>https://idevz.github.io/2017/08/lua-%E6%BA%90%E7%A0%81%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</guid>
      <description>https://github.com/lichuang/Lua-Source-Internal/blob/master/doc/ch06-%E7%83%AD%E6%9B%B4%E6%96%B0.md</description>
    </item>
    
    <item>
      <title>Nginx 性能优化</title>
      <link>https://idevz.github.io/2017/07/nginx-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link>
      <pubDate>Thu, 20 Jul 2017 10:14:50 +0800</pubDate>
      
      <guid>https://idevz.github.io/2017/07/nginx-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</guid>
      <description>Nginx 性能优化 群里有同学发了一篇 《Nginx 性能优化》 的文章，春哥看后，提出以下几点，非常有技术高度的观点，个人认为，这才是技术，才是技术人应该追求的高度。 下面把春哥的原话摘录于此，与君共勉：
居然不提火焰图 gzip 也居然不提 CPU 损耗 另外，不提 Openfile Cache 和共享内存的锁，也是缺憾 另外，高并发下不提请求内存池的配置，也是缺憾 另外，error log 刷得太猛，也是常见的性能瓶颈 而 error log 是不带 buffer 的，比 access log 会更严重 SSL 的优化也完全没提及 性能优化是一个系统化的学问 不是简单的奇技淫巧的列表 火焰图应该作为总纲 然后分门别类 见招拆招 性能优化是一个系统化的学问 不是简单的奇技淫巧的列表</description>
    </item>
    
    <item>
      <title>lua src</title>
      <link>https://idevz.github.io/2017/07/lua-src/</link>
      <pubDate>Fri, 14 Jul 2017 00:27:58 +0800</pubDate>
      
      <guid>https://idevz.github.io/2017/07/lua-src/</guid>
      <description>lua源代码重要文件及其说明。 https://github.com/lichuang/Lua-Source-Internal |文件名 | 说明| |:&amp;mdash;-|:&amp;mdash;-| |luac.c | lua编译器，可将生成的字节码写入文件| |lua.c | 可独立运行的解释器| |lparser.c | Lua语法解析器| |lcode.c | Lua指令生成器（编码器）。luaK_code负责把编码好的指令(Instruction, 其实就是lua_int32)放到指令数组中。| |lopcodes.c | Lua虚拟机的操作码。lua的虚拟机指令是整齐的，都是32位。除了有算数运算、逻辑运算、跳转(jmp/call)等常见CUP指令外，还有lua特有的操作Table\Closure\Upvalue的指令。| |lvm.c | Lua虚拟机, luaV_execute 是解释器的主循环| |lmem.c | Lua内存管理| |lgc.c | luaC_newobj创建对象并加入gc| |lobject.c | Lua语言中数据结构的C描述，比如closure和table| |ltable.c | table相关的操作|</description>
    </item>
    
    <item>
      <title>高性能 Lua 技巧</title>
      <link>https://idevz.github.io/2017/07/%E9%AB%98%E6%80%A7%E8%83%BD-lua-%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Thu, 13 Jul 2017 15:03:03 +0800</pubDate>
      
      <guid>https://idevz.github.io/2017/07/%E9%AB%98%E6%80%A7%E8%83%BD-lua-%E6%8A%80%E5%B7%A7/</guid>
      <description>http://www.lua.org/gems/sample.pdf
http://wuzhiwei.net/lua_performance/
使用local  在代码运行前，Lua 会把源码预编译成一种中间码，类似于 Java 的虚拟机。这种格式然后会通过 C 的解释器进行解释，整个过程其实就是通过一个 while 循环，里面有很多的 switch &amp;hellip; case 语句，一个case对应一条指令来解析。自 Lua 5.0 之后，Lua 采用了一种类似于寄存器的虚拟机模式。Lua用栈来储存其寄存器。每一个活动的函数，Lua 都会其分配一个栈，这个栈用来储存函数里的活动记录。每一个函数的栈都可以储存至多 250 个寄存器，因为栈的长度是用 8 个比特表示的。有了这么多的寄存器，Lua 的预编译器能把所有的 local 变量储存在其中。这就使得 Lua 在获取 local 变量时其效率十分的高。
 看下面的示例代码：
-- local a,b=0,3 a,b=0,3 a=b+1 print( a ) 再看加与不加 local 预编译产生的指令对比：
有 local 修饰，直接 ADD
main &amp;lt;run.lua:0,0&amp;gt; (7 instructions, 28 bytes at 0x8b9530) 0+ params, 4 slots, 0 upvalues, 2 locals, 4 constants, 0 functions 1	[50]	LOADK 0 -1	; 0 2	[50]	LOADK 1 -2	; 3 3	[51]	ADD 0 1 -3	; - 1 4	[52]	GETGLOBAL	2 -4	; print 5	[52]	MOVE 3 0 6	[52]	CALL 2 2 1 7	[52]	RETURN 0 1 没有 local 修饰，先从 Global 中取，计算完的结果再 SETGLOBAL</description>
    </item>
    
    <item>
      <title>深入理解 Lua 元表</title>
      <link>https://idevz.github.io/2017/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-lua-%E5%85%83%E8%A1%A8/</link>
      <pubDate>Thu, 13 Jul 2017 10:07:21 +0800</pubDate>
      
      <guid>https://idevz.github.io/2017/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-lua-%E5%85%83%E8%A1%A8/</guid>
      <description>metatable Lua 元表 元表（metatable）作为 Lua 语言的一大经典语言特性，对于 Lua 语言本身有着重要的意义，本文试图随着日常开发中对 metatable 的深入使用，将我对其理解记录于此。
元表，仅仅关乎元方法 提到元表，就必须要知道元方法，下面是元方法的一个简要列表：
__add(a, b) --加法 __sub(a, b) --减法 __mul(a, b) --乘法 __div(a, b) --除法 __mod(a, b) --取模 __pow(a, b) --乘幂 __unm(a) --相反数 __concat(a, b) --连接 __len(a) --长度 __eq(a, b) --相等 __lt(a, b) --小于 __le(a, b) --小于等于 __index(a, b) --索引查询 __newindex(a, b, c) --索引更新 __call(a, ...) --执行方法调用 __tostring(a) --字符串输出 __metatable --保护元表 元表就是通过在一个表中通过对元方法的实现，来设定元表对应元方法的行为（比如给表实现自定义的 &amp;ldquo;+&amp;rdquo; 加法行为），再通过 setmetatable 方法的调用，将这些定义好的行为附加给需要的表，下面通过一个简单的例子来说明：
-- my.lua local setmetatable = setmetatable local data = {name=&amp;#34;idevz&amp;#34;,site=&amp;#34;idevz.</description>
    </item>
    
    <item>
      <title>ngx ctx bug</title>
      <link>https://idevz.github.io/2017/07/ngx-ctx-bug/</link>
      <pubDate>Wed, 12 Jul 2017 14:55:29 +0800</pubDate>
      
      <guid>https://idevz.github.io/2017/07/ngx-ctx-bug/</guid>
      <description>复现 在 &amp;ldquo;init_worker_by_lua&amp;rdquo; 阶段定义方法 init_vanilla，在 content_by_lua 阶段来调用，使用 local registry = debug.getregistry(); print_r(registry.ngx_lua_ctx_tables) 查看当前存储的所有 key，发现前后两个请求的数据会同时保存在 ngx.ctx 中，按理说 ngx.ctx 表就是用来共享请求内变量的，应该是每个请求有自己的一份，为什么在一个请求中能获取到其他请求的 ngx.ctx ？这个需要细节了解下 ngx.ctx 的实现机制，再回来解析这个问题。
init_vanilla 函数的实现
init_vanilla = function (ngx) Registry.namespace = ngx_var.APP_NAME local REQ_Registry = require(&amp;#39;registry&amp;#39;):new() REQ_Registry[&amp;#39;REQ_URI&amp;#39;] = ngx_var.uri REQ_Registry[&amp;#39;REQ_ARGS&amp;#39;] = ngx_var.args REQ_Registry[&amp;#39;REQ_ARGS_ARR&amp;#39;] = ngx_req.get_uri_args() REQ_Registry[&amp;#39;REQ_HEADERS&amp;#39;] = ngx_req.get_headers() REQ_Registry[&amp;#39;APP_CACHE_PURGE&amp;#39;] = REQ_Registry[&amp;#39;REQ_ARGS_ARR&amp;#39;][&amp;#39;vapurge&amp;#39;] ngx.ctx.REQ_Registry = REQ_Registry if Registry[&amp;#39;VANILLA_INIT&amp;#39;] then return end Registry[&amp;#39;VA_ENV&amp;#39;] = ngx_var.VA_ENV Registry[&amp;#39;APP_NAME&amp;#39;] = Registry.namespace Registry[&amp;#39;APP_ROOT&amp;#39;] = ngx_var.document_root Registry[&amp;#39;APP_HOST&amp;#39;] = ngx_var.</description>
    </item>
    
    <item>
      <title>Lua 实现面向对象</title>
      <link>https://idevz.github.io/2017/07/lua-%E5%AE%9E%E7%8E%B0%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Tue, 11 Jul 2017 16:38:42 +0800</pubDate>
      
      <guid>https://idevz.github.io/2017/07/lua-%E5%AE%9E%E7%8E%B0%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid>
      <description>http://blog.csdn.net/q312998164/article/details/39402771 http://blog.sina.com.cn/s/blog_6b9d508001015qd3.html</description>
    </item>
    
    <item>
      <title>or doc</title>
      <link>https://idevz.github.io/2017/07/or-doc/</link>
      <pubDate>Mon, 10 Jul 2017 20:40:30 +0800</pubDate>
      
      <guid>https://idevz.github.io/2017/07/or-doc/</guid>
      <description>worker-level data sharing Data Sharing within an Nginx Worker
ngx.timer.at (fake) connection
bad request
failed to connect: no such file or directory
Recv failure: Connection reset by peer 3 connections
GET /index/get HTTP/1.1 &amp;gt; User-Agent: curl/7.29.0 &amp;gt; Host: 10.211.55.15:9110 &amp;gt; Accept: / &amp;gt;</description>
    </item>
    
  </channel>
</rss>