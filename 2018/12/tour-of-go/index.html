<!DOCTYPE html>
<html lang='en'><head>
  <meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='description' content='basics Packages, Variables, and Functions Packages Every Go program is made up of packages.
Programs start running in package main.
This program is using the packages with import paths fmt and math/rand.
By convention, the package name is the same as the last element of the import path. For instance, the math/rand package comprises files that begin with the statement package rand.
Note: The environment in which these programs are executed is deterministic, so each time you run the example program rand.'>
<meta name='theme-color' content='#ffcd00'>

<meta property='og:title' content='Tour of Go • 做一个善于思考的学习者'>
<meta property='og:description' content='basics Packages, Variables, and Functions Packages Every Go program is made up of packages.
Programs start running in package main.
This program is using the packages with import paths fmt and math/rand.
By convention, the package name is the same as the last element of the import path. For instance, the math/rand package comprises files that begin with the statement package rand.
Note: The environment in which these programs are executed is deterministic, so each time you run the example program rand.'>
<meta property='og:url' content='http://idevz.github.io/2018/12/tour-of-go/'>
<meta property='og:site_name' content='做一个善于思考的学习者'>
<meta property='og:type' content='article'><meta property='article:section' content='tech'><meta property='article:tag' content='Golang'><meta property='article:published_time' content='2018-12-11T11:33:38&#43;08:00'/><meta property='article:modified_time' content='2019-04-08T22:05:43&#43;08:00'/><meta name='twitter:card' content='summary'>

<meta name="generator" content="Hugo 0.60.0-DEV" />

  <title>Tour of Go • 做一个善于思考的学习者</title>
  <link rel='canonical' href='http://idevz.github.io/2018/12/tour-of-go/'>
  
  
  <link rel='icon' href='http://idevz.github.io/favicon.ico'>
<link rel='stylesheet' href='http://idevz.github.io/assets/css/main.6a060eb7.css'><style>
:root{--color-accent:#ffcd00;}
</style>

<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-71947507-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  

</head>
<body class='page type-tech'>

  <div class='site'><a class='screen-reader-text' href='#content'>Skip to Content</a><div class='main'><nav id='main-menu' class='menu main-menu' aria-label='Main Menu'>
  <div class='container'>
    
    <ul><li class='item'>
        <a href='http://idevz.github.io/'>idevz.org</a>
      </li><li class='item'>
        <a href='http://idevz.github.io/tech/'>技术</a>
      </li><li class='item'>
        <a href='http://idevz.github.io/tools/'>工具</a>
      </li><li class='item'>
        <a href='http://idevz.github.io/life/'>Life</a>
      </li><li class='item'>
        <a href='http://idevz.github.io/page/about/'>关于</a>
      </li></ul>
  </div>
</nav><div class='header-widgets'>
        <div class='container'></div>
      </div>

      <header id='header' class='header site-header'>
        <div class='container sep-after'>
          <div class='header-info'><p class='site-title title'>做一个善于思考的学习者</p><p class='desc site-desc'>Every Day Create Your History.</p>
          </div>
        </div>
      </header>

      <main id='content'>


<article lang='en' class='entry'>
  <header class='header entry-header'>
  <div class='container sep-after'>
    <div class='header-info'>
      <h1 class='title'>Tour of Go</h1>
      

    </div>
    <div class='entry-meta'>
  <span class='posted-on'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"/>
  <line x1="16" y1="2" x2="16" y2="6"/>
  <line x1="8" y1="2" x2="8" y2="6"/>
  <line x1="3" y1="10" x2="21" y2="10"/>
  
</svg>
<span class='screen-reader-text'>Posted on </span>
  <time class='entry-date' datetime='2018-12-11T11:33:38&#43;08:00'>2018, Dec 11</time>
</span>

  
  
<span class='reading-time'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <circle cx="12" cy="12" r="10"/>
  <polyline points="12 6 12 12 15 15"/>
  
</svg>
55 mins read
</span>


</div>


  </div>
</header>

  
  
<details class='container entry-toc'>
  <summary class='title'>
    <span>Table of Contents</span>
  </summary>
  <nav id="TableOfContents">
<ul>
<li><a href="#basics">basics</a>
<ul>
<li><a href="#packages-variables-and-functions">Packages, Variables, and Functions</a>
<ul>
<li><a href="#packages">Packages</a></li>
<li><a href="#imports">Imports</a></li>
<li><a href="#exported-names">Exported names</a></li>
<li><a href="#functions">Functions</a></li>
<li><a href="#functions-continued">Functions continued</a></li>
<li><a href="#multiple-results">Multiple results</a></li>
<li><a href="#named-return-values">Named return values</a></li>
<li><a href="#variables">Variables</a></li>
<li><a href="#variables-with-initializers">Variables with initializers</a></li>
<li><a href="#short-variable-declarations">Short variable declarations</a></li>
<li><a href="#basic-types">Basic Types</a></li>
<li><a href="#zero-values">Zero Values</a></li>
<li><a href="#type-conversions">Type conversions</a></li>
<li><a href="#type-inference">Type inference</a></li>
<li><a href="#constants">Constants</a></li>
<li><a href="#numeric-constants">Numeric Constants</a></li>
</ul></li>
<li><a href="#flow-control-statements-for-if-else-switch-and-defer">Flow control statements:for, if, else, switch and defer</a>
<ul>
<li><a href="#for">For</a></li>
<li><a href="#for-continued">For continued</a></li>
<li><a href="#for-is-go-s-while">For is Go’s “while”</a></li>
<li><a href="#forever">Forever</a></li>
<li><a href="#if">If</a></li>
<li><a href="#if-with-a-short-statement">If with a short statement</a></li>
<li><a href="#if-and-else">If and else</a></li>
<li><a href="#exercise-loops-and-functions">Exercise: Loops and Functions</a></li>
<li><a href="#switch">Switch</a></li>
<li><a href="#switch-evaluation-order">Switch evaluation order</a></li>
<li><a href="#switch-with-no-condition">Switch with no condition</a></li>
<li><a href="#defer">Defer</a></li>
<li><a href="#stacking-defers">Stacking defers</a></li>
</ul></li>
<li><a href="#more-types-structs-slices-and-maps">More types: structs, slices, and maps</a>
<ul>
<li><a href="#pointers">Pointers</a></li>
<li><a href="#structs">Structs</a></li>
<li><a href="#struct-fields">Struct Fields</a></li>
<li><a href="#pointers-to-structs">Pointers to Structs</a></li>
<li><a href="#struct-literals">Struct Literals</a></li>
<li><a href="#arrays">Arrays</a></li>
<li><a href="#slices">Slices</a></li>
<li><a href="#slices-are-like-references-to-arrays">Slices are like references to arrays</a></li>
<li><a href="#slice-literals">Slice literals</a></li>
<li><a href="#slice-defaults">Slice defaults</a></li>
<li><a href="#slice-length-and-capacity">Slice length and capacity</a></li>
<li><a href="#nil-slices">Nil slices</a></li>
<li><a href="#creating-a-slice-with-make">Creating a slice with make</a></li>
<li><a href="#slices-of-slices">Slices of slices</a></li>
<li><a href="#appending-to-a-slice">Appending to a slice</a></li>
<li><a href="#range">Range</a></li>
<li><a href="#range-continued">Range continued</a></li>
<li><a href="#exercise-slices">Exercise: Slices</a></li>
<li><a href="#maps">Maps</a></li>
<li><a href="#map-literals">Map literals</a></li>
<li><a href="#map-literals-continued">Map literals continued</a></li>
<li><a href="#mutating-maps">Mutating Maps</a></li>
<li><a href="#exercise-maps">Exercise: Maps</a></li>
<li><a href="#function-values">Function values</a></li>
<li><a href="#function-closures">Function closures</a></li>
<li><a href="#exercise-fibonacci-closure">Exercise: Fibonacci closure</a></li>
</ul></li>
</ul></li>
<li><a href="#methods-and-interface">Methods and Interface</a>
<ul>
<li><a href="#methods-and-interfaces">Methods and Interfaces</a>
<ul>
<li><a href="#methods">Methods</a></li>
<li><a href="#methods-are-functions">Methods are functions</a></li>
<li><a href="#methods-continued">Methods continued</a></li>
<li><a href="#pointer-receivers">Pointer receivers</a></li>
<li><a href="#pointers-and-functions">Pointers and functions</a></li>
<li><a href="#methods-and-pointer-indirection">Methods and pointer indirection</a></li>
<li><a href="#methods-and-pointer-indirection-2">Methods and pointer indirection(2)</a></li>
<li><a href="#choosing-a-value-or-pointer-receiver">Choosing a value or pointer receiver</a></li>
<li><a href="#interfaces">Interfaces</a></li>
<li><a href="#interfaces-are-implemented-implicitly">Interfaces are implemented implicitly</a></li>
<li><a href="#interface-values">Interface values</a></li>
<li><a href="#interface-values-with-nil-underlying-values">Interface values with nil underlying values</a></li>
<li><a href="#nil-interface-values">Nil interface values</a></li>
<li><a href="#the-empty-interface">The empty interface</a></li>
<li><a href="#type-assertions">Type assertions</a></li>
<li><a href="#type-switches">Type switches</a></li>
<li><a href="#stringers">Stringers</a></li>
<li><a href="#exercise-stringers">Exercise: Stringers</a></li>
<li><a href="#errors">Errors</a></li>
<li><a href="#exercise-errors">Exercise: Errors</a></li>
<li><a href="#readers">Readers</a></li>
<li><a href="#exercise-readers">Exercise:Readers</a></li>
<li><a href="#exercise-rot13reader">Exercise: rot13Reader</a></li>
<li><a href="#images">Images</a></li>
<li><a href="#exercise-images">Exercise:Images</a></li>
</ul></li>
</ul></li>
<li><a href="#concurrency">Concurrency</a>
<ul>
<li><a href="#concurrency-1">Concurrency</a>
<ul>
<li><a href="#goroutines">Goroutines</a></li>
<li><a href="#channels">Channels</a></li>
<li><a href="#buffered-channels">Buffered Channels</a></li>
<li><a href="#range-and-close">Range and Close</a></li>
<li><a href="#select">Select</a></li>
<li><a href="#default-selection">Default Selection</a></li>
<li><a href="#exercise-equivalent-binary-trees">Exercise: Equivalent Binary Trees</a></li>
<li><a href="#exercise-equivalent-binary-trees-1">Exercise: Equivalent Binary Trees</a></li>
<li><a href="#sync-mutex">sync.Mutex</a></li>
<li><a href="#exercise-web-crawler">Exercise: Web Crawler</a></li>
<li><a href="#where-to-go-from-here">Where to Go from here …</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
</details>


  <div class='container entry-content'>
  

<h1 id="basics">basics</h1>

<h2 id="packages-variables-and-functions">Packages, Variables, and Functions</h2>

<h3 id="packages">Packages</h3>

<p>Every Go program is made up of packages.</p>

<p>Programs start running in package <code>main</code>.</p>

<p>This program is using the packages with import paths <code>fmt</code> and <code>math/rand</code>.</p>

<p>By convention, the package name is the same as the last element of the import path. For instance, the <code>math/rand</code> package comprises files that begin with the statement <code>package rand</code>.</p>

<p>Note: The environment in which these programs are executed is deterministic, so each time you run the example program <code>rand.Intn</code> will return the same number. (To see a different number, seed the number generator; see <code>rand.Seed</code>. Time is constant in the playground, so you will need to use something else as the seed.)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;math/rand&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">rand</span>.<span style="color:#a6e22e">Seed</span>(<span style="color:#ae81ff">22</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;My favorite number is&#34;</span>, <span style="color:#a6e22e">rand</span>.<span style="color:#a6e22e">Intn</span>(<span style="color:#ae81ff">10066990</span>))
}</code></pre></div>
<p>每个 Go 程序都由包组成。</p>

<p>程序从 <code>main</code> 包开始运行。</p>

<p>（本示例）程序使用包含导入路径 <code>fmt</code> 和 <code>math/rand</code> 的包。</p>

<p>按照惯例，包名与导入路径的最后一个元素相同。例如 <code>math/rand</code> 包中包含以 <code>package rand</code> 语句开头的文件。</p>

<p>注意：执行这些程序的环境都是确定的，因此你每次运行这个示例 <code>rand.Intn</code> 都将返回相同的数字（为了得到不同的数字，需要生成随机种子；查看 <code>rand.Seed</code>，运行环境的时间是一个常量，所以你需要使用其他的东西来作为随机种子）。</p>

<h3 id="imports">Imports</h3>

<p>This code groups the imports into a parenthesized, &ldquo;factored&rdquo; import statement.</p>

<p>You can also write multiple import statements, like:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;math&#34;</span></code></pre></div>
<p>But it is good style to use the factored import statement.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;math&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Now you have %g problems.\n&#34;</span>, <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Sqrt</span>(<span style="color:#ae81ff">7</span>))
}</code></pre></div>
<p>这段代码将所有导入的包组织在一个括号内，“分解” 导入语句。</p>

<p>你还可以编写多条包导入语句，例如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;math&#34;</span></code></pre></div>
<p>但是，使用分解的导入语句是一种比较好的风格。</p>

<h3 id="exported-names">Exported names</h3>

<p>In Go, a name is exported if it begins with a capital letter. For example, Pizza is an exported name, as is Pi, which is exported from the math package.</p>

<p>pizza and pi do not start with a capital letter, so they are not exported.</p>

<p>When importing a package, you can refer only to its exported names. Any &ldquo;unexported&rdquo; names are not accessible from outside the package.</p>

<p>Run the code. Notice the error message.</p>

<p>To fix the error, rename math.pi to math.Pi and try it again.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;math&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">pi</span>)
}</code></pre></div>
<p>在 Go 语言中，以大写字母开头的命名将被导出。例如， <code>Pizza</code> 是一个被导出的变量，<code>Pi</code> 也是 <code>math</code> 包中导出的变量。</p>

<p><code>pizza</code> 和 <code>pi</code> 没有以大写字母开头，因此他们不会被导出。</p>

<p>导入一个包的时候，只能引用那些导出的命名，任何 “未导出” 的命名将无法在包外被访问。</p>

<p>运行代码，注意错误信息（如下）。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">prog.go:9:14: cannot refer to unexported name math.pi
prog.go:9:14: undefined: math.pi

Go build failed.</code></pre></div>
<p>要修复错误，请将 <code>math.pi</code> 重命名为 <code>math.Pi</code> 再重试一次。</p>

<h3 id="functions">Functions</h3>

<p>A function can take zero or more arguments.</p>

<p>In this example, add takes two parameters of type int.</p>

<p>Notice that the type comes after the variable name.</p>

<p>(For more about why types look the way they do, see the article on Go&rsquo;s declaration syntax.)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">add</span>(<span style="color:#a6e22e">x</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">add</span>(<span style="color:#ae81ff">42</span>, <span style="color:#ae81ff">13</span>))
}</code></pre></div>
<p>函数可以使用零个或多个参数。</p>

<p>在此示例中，<code>add</code> 传入两个 <code>int</code> 类型的变量。</p>

<p>请注意，该类型在变量名之后。</p>

<p>（想了解更多关于为什么类型声明是看到的这样，请查阅<a href="https://blog.golang.org/gos-declaration-syntax">《Go 声明式语法的艺术》</a>）</p>

<h3 id="functions-continued">Functions continued</h3>

<p>When two or more consecutive named function parameters share a type, you can omit the type from all but the last.</p>

<p>In this example, we shortened</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">x</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span></code></pre></div>
<p>to</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span></code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">add</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">add</span>(<span style="color:#ae81ff">42</span>, <span style="color:#ae81ff">13</span>))
}</code></pre></div>
<p>当两个或多个连续命名的函数参数共享一个类型时，你可以省略除了最后一个参数的其他参数的类型。</p>

<p>在这个例子中我们可以将</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">x</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span></code></pre></div>
<p>简化为</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span></code></pre></div>
<h3 id="multiple-results">Multiple results</h3>

<p>A function can return any number of results.</p>

<p>The swap function returns two strings.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">swap</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">string</span>) (<span style="color:#66d9ef">string</span>, <span style="color:#66d9ef">string</span>) {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">x</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">swap</span>(<span style="color:#e6db74">&#34;hello&#34;</span>, <span style="color:#e6db74">&#34;world&#34;</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span>)
}</code></pre></div>
<p>函数可以返回任意数量的结果。</p>

<p><code>swap</code> 函数返回两个字符串。</p>

<h3 id="named-return-values">Named return values</h3>

<p>Go&rsquo;s return values may be named. If so, they are treated as variables defined at the top of the function.</p>

<p>These names should be used to document the meaning of the return values.</p>

<p>A return statement without arguments returns the named return values. This is known as a &ldquo;naked&rdquo; return.</p>

<p>Naked return statements should be used only in short functions, as with the example shown here. They can harm readability in longer functions.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">split</span>(<span style="color:#a6e22e">sum</span> <span style="color:#66d9ef">int</span>) (<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#a6e22e">x</span> = <span style="color:#a6e22e">sum</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">4</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">9</span>
	<span style="color:#a6e22e">y</span> = <span style="color:#a6e22e">sum</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">x</span>
	<span style="color:#66d9ef">return</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">split</span>(<span style="color:#ae81ff">17</span>))
}</code></pre></div>
<p>可以命名 Go 的返回值. 如果是这样，它们将被视为在函数顶部定义的变量。</p>

<p>这些名称应用于记录返回值的含义。</p>

<p>一个不带参数的 <code>return</code> 语句将返回事先命名的返回值。这种被称为 “裸” 返回。</p>

<p>裸返回语句只被使用在较短的函数中，就像示例中演示的那样。这种方式在长函数体中会影响代码可读性。</p>

<h3 id="variables">Variables</h3>

<p>The var statement declares a list of variables; as in function argument lists, the type is last.</p>

<p>A var statement can be at package or function level. We see both in this example.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">python</span>, <span style="color:#a6e22e">java</span> <span style="color:#66d9ef">bool</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">python</span>, <span style="color:#a6e22e">java</span>)
}</code></pre></div>
<p><code>var</code> 语句声明了一个变量列表； 就像在函数参数列表中那样，类型是最后一个。</p>

<p><code>var</code> 语句可以是包或者函数级别，我们在这个例子中都看到了。</p>

<h3 id="variables-with-initializers">Variables with initializers</h3>

<p>A var declaration can include initializers, one per variable.</p>

<p>If an initializer is present, the type can be omitted; the variable will take the type of the initializer.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">j</span> <span style="color:#66d9ef">int</span> = <span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">python</span>, <span style="color:#a6e22e">java</span> = <span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">false</span>, <span style="color:#e6db74">&#34;no!&#34;</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">j</span>, <span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">python</span>, <span style="color:#a6e22e">java</span>)
}</code></pre></div>
<p>变量的声明可以同时包含初始化，每个变量一个。</p>

<p>如果变量已经初始化，则变量类型可以省略；变量将会使用初始化值的类型作为变量类型。</p>

<h3 id="short-variable-declarations">Short variable declarations</h3>

<p>Inside a function, the := short assignment statement can be used in place of a var declaration with implicit type.</p>

<p>Outside a function, every statement begins with a keyword (var, func, and so on) and so the := construct is not available.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span>  =<span style="color:#66d9ef">true</span>
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>
	<span style="color:#a6e22e">k</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">3</span>
	<span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">python</span>, <span style="color:#a6e22e">java</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">false</span>, <span style="color:#e6db74">&#34;no!&#34;</span>

	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">j</span>, <span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">python</span>, <span style="color:#a6e22e">java</span>)
}</code></pre></div>
<p>在函数内部，可以使用短变量赋值语句 <code>:=</code> 来代替隐式类型声明的 <code>var</code> 语句。</p>

<p>在函数外部，每个语句都以关键字（<code>var</code>、<code>func</code> 等）开头，因此 <code>:=</code> 结构不允许在函数外使用。</p>

<h3 id="basic-types">Basic Types</h3>

<p>Go&rsquo;s basic types are</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">bool</span>

<span style="color:#66d9ef">string</span>

<span style="color:#66d9ef">int</span>  <span style="color:#66d9ef">int8</span>  <span style="color:#66d9ef">int16</span>  <span style="color:#66d9ef">int32</span>  <span style="color:#66d9ef">int64</span>
<span style="color:#66d9ef">uint</span> <span style="color:#66d9ef">uint8</span> <span style="color:#66d9ef">uint16</span> <span style="color:#66d9ef">uint32</span> <span style="color:#66d9ef">uint64</span> <span style="color:#66d9ef">uintptr</span>

<span style="color:#66d9ef">byte</span> <span style="color:#75715e">// alias for uint8
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">rune</span> <span style="color:#75715e">// alias for int32
</span><span style="color:#75715e"></span>     <span style="color:#75715e">// represents a Unicode code point
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">float32</span> <span style="color:#66d9ef">float64</span>

<span style="color:#66d9ef">complex64</span> <span style="color:#66d9ef">complex128</span></code></pre></div>
<p>The example shows variables of several types, and also that variable declarations may be &ldquo;factored&rdquo; into blocks, as with import statements.</p>

<p>The <code>int</code>, <code>uint</code>, and <code>uintptr</code> types are usually 32 bits wide on 32-bit systems and 64 bits wide on 64-bit systems. When you need an integer value you should use <code>int</code> unless you have a specific reason to use a sized or unsigned integer type.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;math/cmplx&#34;</span>
)

<span style="color:#66d9ef">var</span> (
	<span style="color:#a6e22e">ToBe</span>   <span style="color:#66d9ef">bool</span>       = <span style="color:#66d9ef">false</span>
	<span style="color:#a6e22e">MaxInt</span> <span style="color:#66d9ef">uint64</span>     = <span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">64</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
	<span style="color:#a6e22e">z</span>      <span style="color:#66d9ef">complex128</span> = <span style="color:#a6e22e">cmplx</span>.<span style="color:#a6e22e">Sqrt</span>(<span style="color:#f92672">-</span><span style="color:#ae81ff">5</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">12i</span>)
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Type: %T Value: %v\n&#34;</span>, <span style="color:#a6e22e">ToBe</span>, <span style="color:#a6e22e">ToBe</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Type: %T Value: %v\n&#34;</span>, <span style="color:#a6e22e">MaxInt</span>, <span style="color:#a6e22e">MaxInt</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Type: %T Value: %v\n&#34;</span>, <span style="color:#a6e22e">z</span>, <span style="color:#a6e22e">z</span>)
}</code></pre></div>
<p>Go 的基础数据类型有：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">bool</span>

<span style="color:#66d9ef">string</span>

<span style="color:#66d9ef">int</span>  <span style="color:#66d9ef">int8</span>  <span style="color:#66d9ef">int16</span>  <span style="color:#66d9ef">int32</span>  <span style="color:#66d9ef">int64</span>
<span style="color:#66d9ef">uint</span> <span style="color:#66d9ef">uint8</span> <span style="color:#66d9ef">uint16</span> <span style="color:#66d9ef">uint32</span> <span style="color:#66d9ef">uint64</span> <span style="color:#66d9ef">uintptr</span>

<span style="color:#66d9ef">byte</span> <span style="color:#75715e">// alias for uint8
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">rune</span> <span style="color:#75715e">// alias for int32
</span><span style="color:#75715e"></span>     <span style="color:#75715e">// represents a Unicode code point
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">float32</span> <span style="color:#66d9ef">float64</span>

<span style="color:#66d9ef">complex64</span> <span style="color:#66d9ef">complex128</span></code></pre></div>
<p>该示例显示了几种类型的变量，并且变量声明可以像 <code>import</code> 语句那样分解为块。</p>

<p><code>int</code>、<code>uint</code> 和 <code>uintptr</code> 通常在 32 位系统是 32 位宽，在 64 位系统是 64 位宽，当你需要一个整型数值你应该使用 <code>int</code> 来声明变量，除非你有特殊的原因需要使用大小或者无符号的整数类型。</p>

<h3 id="zero-values">Zero Values</h3>

<p>Variables declared without an explicit initial value are given their zero value.</p>

<p>The zero value is:</p>

<p><code>0</code> for numeric types,
<code>false</code> for the boolean type, and
<code>””</code> (the empty string) for strings.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">f</span> <span style="color:#66d9ef">float64</span>
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">bool</span>
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%v %v %v %q\n&#34;</span>, <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">f</span>, <span style="color:#a6e22e">b</span>, <span style="color:#a6e22e">s</span>)
}</code></pre></div>
<p>没有明确初始值的变量的值为零值。</p>

<p>零值有：</p>

<p><code>0</code> 作为数字类型的零值
<code>false</code> 是布尔类型的零值，还有
<code>””</code> （空字符串）作为字符串类型的零值</p>

<h3 id="type-conversions">Type conversions</h3>

<p>The expression <code>T(v)</code> converts the value <code>v</code> to the type <code>T</code>.</p>

<p>Some numeric conversions:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span> = <span style="color:#ae81ff">42</span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">f</span> <span style="color:#66d9ef">float64</span> = float64(<span style="color:#a6e22e">i</span>)
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">u</span> <span style="color:#66d9ef">uint</span> = uint(<span style="color:#a6e22e">f</span>)</code></pre></div>
<p>Or, put more simply:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">42</span>
<span style="color:#a6e22e">f</span> <span style="color:#f92672">:=</span> float64(<span style="color:#a6e22e">i</span>)
<span style="color:#a6e22e">u</span> <span style="color:#f92672">:=</span> uint(<span style="color:#a6e22e">f</span>)</code></pre></div>
<p>Unlike in C, in Go assignment between items of different type requires an explicit conversion. Try removing the <code>float64</code> or <code>uint</code> conversions in the example and see what happens.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;math&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span> = <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">f</span> <span style="color:#66d9ef">float64</span> = <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Sqrt</span>((<span style="color:#a6e22e">x</span><span style="color:#f92672">*</span><span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span><span style="color:#f92672">*</span><span style="color:#a6e22e">y</span>))
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">z</span> <span style="color:#66d9ef">uint</span> = uint(<span style="color:#a6e22e">f</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">z</span>)
}</code></pre></div>
<p>表达式 <code>T(v)</code> 将值 <code>v</code> 转换为类型 <code>T</code> 的值.</p>

<p>一些数字类型的转换：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span> = <span style="color:#ae81ff">42</span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">f</span> <span style="color:#66d9ef">float64</span> = float64(<span style="color:#a6e22e">i</span>)
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">u</span> <span style="color:#66d9ef">uint</span> = uint(<span style="color:#a6e22e">f</span>)</code></pre></div>
<p>或者简写为：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">42</span>
<span style="color:#a6e22e">f</span> <span style="color:#f92672">:=</span> float64(<span style="color:#a6e22e">i</span>)
<span style="color:#a6e22e">u</span> <span style="color:#f92672">:=</span> uint(<span style="color:#a6e22e">f</span>)</code></pre></div>
<p>不像 C 语言那样，在 Go 语言中，在两个不同类型的变量间做赋值运算必须显示进行类型转换。尝试删除示例中  <code>float64</code> 或者 <code>uint</code> 的类型转换看看会发生什么（错误信息如下：）。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">prog.go:10:33: cannot use x * x + y * y <span style="color:#f92672">(</span>type int<span style="color:#f92672">)</span> as type float64 in argument to math.Sqrt
prog.go:11:6: cannot use f <span style="color:#f92672">(</span>type float64<span style="color:#f92672">)</span> as type uint in assignment

Go build failed.</code></pre></div>
<h3 id="type-inference">Type inference</h3>

<p>When declaring a variable without specifying an explicit type (either by using the <code>:=</code> syntax or <code>var =</code> expression syntax), the variable&rsquo;s type is inferred from the value on the right hand side.</p>

<p>When the right hand side of the declaration is typed, the new variable is of that same type:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>
<span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">//</span> <span style="color:#a6e22e">j</span> <span style="color:#a6e22e">is</span> <span style="color:#a6e22e">an</span> <span style="color:#66d9ef">int</span></code></pre></div>
<p>But when the right hand side contains an untyped numeric constant, the new variable may be an <code>int</code>, <code>float64</code>, or <code>complex128</code> depending on the precision of the constant:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">42</span>           <span style="color:#75715e">// int
</span><span style="color:#75715e"></span><span style="color:#a6e22e">f</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">3.142</span>        <span style="color:#75715e">// float64
</span><span style="color:#75715e"></span><span style="color:#a6e22e">g</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0.867</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.5i</span> <span style="color:#f92672">//</span> <span style="color:#66d9ef">complex128</span></code></pre></div>
<p>Try changing the initial value of <code>v</code> in the example code and observe how its type is affected.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">42.7</span><span style="color:#f92672">+</span><span style="color:#ae81ff">0.4i</span> <span style="color:#75715e">// change me!
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;v is of type %T\n&#34;</span>, <span style="color:#a6e22e">v</span>)
}</code></pre></div>
<p>当声明变量而不指定显式类型时（通过使用 <code>:=</code> 语法，或 <code>var =</code> 表达式语法），从右值推断变量的类型。</p>

<p>当右值的声明是具有变量类型的，则新声明的变量将具有相同的类型：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>
<span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">//</span> <span style="color:#a6e22e">j</span> <span style="color:#a6e22e">is</span> <span style="color:#a6e22e">an</span> <span style="color:#66d9ef">int</span></code></pre></div>
<p>但是，当右值包含无类型的数字常量，则新的变量可能是 <code>int</code>， <code>float64</code>，或者 <code>complex128</code>，取决于常量本身的精度：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">42</span>           <span style="color:#75715e">// int
</span><span style="color:#75715e"></span><span style="color:#a6e22e">f</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">3.142</span>        <span style="color:#75715e">// float64
</span><span style="color:#75715e"></span><span style="color:#a6e22e">g</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0.867</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.5i</span> <span style="color:#f92672">//</span> <span style="color:#66d9ef">complex128</span></code></pre></div>
<p>尝试改变示例中 <code>v</code> 的初始值，并观察如何影响其类型的。</p>

<h3 id="constants">Constants</h3>

<p>Constants are declared like variables, but with the <code>const</code> keyword.</p>

<p>Constants can be character, string, boolean, or numeric values.</p>

<p>Constants cannot be declared using the <code>:=</code> syntax.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">Pi</span> = <span style="color:#ae81ff">3.14</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">World</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;世界&#34;</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Hello&#34;</span>, <span style="color:#a6e22e">World</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Happy&#34;</span>, <span style="color:#a6e22e">Pi</span>, <span style="color:#e6db74">&#34;Day&#34;</span>)

	<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">Truth</span> = <span style="color:#66d9ef">true</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Go rules?&#34;</span>, <span style="color:#a6e22e">Truth</span>)
}</code></pre></div>
<p>常量的声明与变量类似，不过需要加上 <code>const</code> 关键字。</p>

<p>常量可以是 字符、字符串、布尔值或者数值。</p>

<p>不允许使用短变量赋值语法 <code>:=</code> 来声明常量。</p>

<p>示例运行错误信息如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">prog.go:8:8: missing value in const declaration
prog.go:8:14: syntax error: unexpected :<span style="color:#f92672">=</span> at end of statement

Go build failed.</code></pre></div>
<h3 id="numeric-constants">Numeric Constants</h3>

<p>Numeric constants are high-precision values.</p>

<p>An untyped constant takes the type needed by its context.</p>

<p>Try printing <code>needInt(Big)</code> too.</p>

<p>(An <code>int</code> can store at maximum a 64-bit integer, and sometimes less.)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">const</span> (
	<span style="color:#75715e">// Create a huge number by shifting a 1 bit left 100 places.
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// In other words, the binary number that is 1 followed by 100 zeroes.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">Big</span> = <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">100</span>
	<span style="color:#75715e">// Shift it right again 99 places, so we end up with 1&lt;&lt;1, or 2.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">Small</span> = <span style="color:#a6e22e">Big</span> <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">99</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">needInt</span>(<span style="color:#a6e22e">x</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> { <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span><span style="color:#f92672">*</span><span style="color:#ae81ff">10</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> }
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">needFloat</span>(<span style="color:#a6e22e">x</span> <span style="color:#66d9ef">float64</span>) <span style="color:#66d9ef">float64</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0.1</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">needInt</span>(<span style="color:#a6e22e">Small</span>))
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">needInt</span>(<span style="color:#a6e22e">Big</span>))
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">needFloat</span>(<span style="color:#a6e22e">Small</span>))
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">needFloat</span>(<span style="color:#a6e22e">Big</span>))
}</code></pre></div>
<p>数字常量是高精度值。</p>

<p>无类型的常量采用其上下文所需类型。</p>

<p>尝试打印 <code>needInt(Big)</code> 。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">prog.go:20:22: constant <span style="color:#ae81ff">1267650600228229401496703205376</span> overflows int

Go build failed.</code></pre></div>
<p>（<code>int</code> 最多可以存储 64 位整数，有时甚至更少）</p>

<h2 id="flow-control-statements-for-if-else-switch-and-defer">Flow control statements:for, if, else, switch and defer</h2>

<h3 id="for">For</h3>

<p>Go has only one looping construct, the <code>for</code> loop.</p>

<p>The basic <code>for</code> loop has three components separated by semicolons:</p>

<p>the <code>init</code> statement: executed before the first iteration
the condition expression: evaluated before every iteration
the post statement: executed at the end of every iteration</p>

<p>The init statement will often be a short variable declaration, and the variables declared there are visible only in the scope of the <code>for</code> statement.</p>

<p>The loop will stop iterating once the boolean condition evaluates to <code>false</code>.</p>

<p>Note: Unlike other languages like C, Java, or JavaScript there are no parentheses surrounding the three components of the <code>for</code> statement and the braces <code>{</code> <code>}</code> are always required.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">sum</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">sum</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">i</span>
	}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">sum</span>)
}</code></pre></div>
<p>Go 语言只有一种循环结构， 即 <code>for</code> 循环。</p>

<p>最基本的 <code>for</code> 循环有三个由分号分割的组件构成：</p>

<p>初始化语句: 在第一次迭代前执行
条件表达式: 在每次迭代前计算
Post 语句: 每次迭代结束之后执行</p>

<p>初始化语句通常是一个短变量声明表达式，并且声明的变量仅仅在整个 <code>for</code> 语句的范围内可见。</p>

<p>一旦条件表达式计算结果值为 <code>false</code>，循环将立即停止迭代。</p>

<p>注意：不像其他语言，比如 C、Java 或者 JavaScript，<code>for</code> 语句这三个组件周围并没有括号，但是花括号 <code>{</code> <code>}</code> 通常是需要的。</p>

<h3 id="for-continued">For continued</h3>

<p>The init and post statements are optional.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">sum</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>
	<span style="color:#66d9ef">for</span> ; <span style="color:#a6e22e">sum</span> &lt; <span style="color:#ae81ff">1000</span>; {
		<span style="color:#a6e22e">sum</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">sum</span>
	}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">sum</span>)
}</code></pre></div>
<p>初始化语句和 Post 语句是可选的。</p>

<h3 id="for-is-go-s-while">For is Go’s “while”</h3>

<p>At that point you can drop the semicolons: C&rsquo;s <code>while</code> is spelled <code>for</code> in Go.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">sum</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">sum</span> &lt; <span style="color:#ae81ff">1000</span> {
		<span style="color:#a6e22e">sum</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">sum</span>
	}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">sum</span>)
}</code></pre></div>
<p>此时你可以省略分号： C 语言的 <code>while</code> 可以写成 Go 语言中的 <code>for</code> 。</p>

<h3 id="forever">Forever</h3>

<p>If you omit the loop condition it loops forever, so an infinite loop is compactly expressed.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">for</span> {
	}
}</code></pre></div>
<p>如果省略了循环的条件判断语句，循环将永远运行下去，因此可以紧凑地表达无限循环。。</p>

<h3 id="if">If</h3>

<p>Go&rsquo;s <code>if</code> statements are like its <code>for</code> loops; the expression need not be surrounded by parentheses <code>(</code> <code>)</code> but the braces <code>{</code> <code>}</code> are required.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;math&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sqrt</span>(<span style="color:#a6e22e">x</span> <span style="color:#66d9ef">float64</span>) <span style="color:#66d9ef">string</span> {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">x</span> &lt; <span style="color:#ae81ff">0</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">sqrt</span>(<span style="color:#f92672">-</span><span style="color:#a6e22e">x</span>) <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;i&#34;</span>
	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprint</span>(<span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Sqrt</span>(<span style="color:#a6e22e">x</span>))
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">sqrt</span>(<span style="color:#ae81ff">2</span>), <span style="color:#a6e22e">sqrt</span>(<span style="color:#f92672">-</span><span style="color:#ae81ff">4</span>))
}</code></pre></div>
<p>Go 的 <code>if</code> 语句与其 <code>for</code> 循环语句类似；条件表达式不需要小括号 <code>(</code> <code>)</code> 括起来，但是花括号 <code>{</code> <code>}</code> 是必须的。</p>

<h3 id="if-with-a-short-statement">If with a short statement</h3>

<p>Like <code>for</code>, the <code>if</code> statement can start with a short statement to execute before the condition.</p>

<p>Variables declared by the statement are only in scope until the end of the <code>if</code>.</p>

<p>(Try using <code>v</code> in the last <code>return</code> statement.)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;math&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">pow</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">lim</span> <span style="color:#66d9ef">float64</span>) <span style="color:#66d9ef">float64</span> {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Pow</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">n</span>); <span style="color:#a6e22e">v</span> &lt; <span style="color:#a6e22e">lim</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">v</span>
	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">lim</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(
		<span style="color:#a6e22e">pow</span>(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">10</span>),
		<span style="color:#a6e22e">pow</span>(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">20</span>),
	)
}</code></pre></div>
<p>跟 <code>for</code> 类似，<code>if</code> 语句可以在执行条件判断之前执行短变量赋值语句。</p>

<p>这种语句声明的变量作用域仅在 <code>if</code> 语句范围内。</p>

<p>（尝试在最后的 <code>return</code> 语句中使用 变量 <code>v</code>，运行结果如下：）</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">prog.go:12:9: undefined: v

Go build failed.</code></pre></div>
<h3 id="if-and-else">If and else</h3>

<p>Variables declared inside an <code>if</code> short statement are also available inside any of the <code>else</code> blocks.</p>

<p>(Both calls to <code>pow</code> return their results before the call to <code>fmt.Println</code> in main begins.)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;math&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">pow</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">lim</span> <span style="color:#66d9ef">float64</span>) <span style="color:#66d9ef">float64</span> {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Pow</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">n</span>); <span style="color:#a6e22e">v</span> &lt; <span style="color:#a6e22e">lim</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">v</span>
	} <span style="color:#66d9ef">else</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%g &gt;= %g\n&#34;</span>, <span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">lim</span>)
	}
	<span style="color:#75715e">// can&#39;t use v here, though
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">lim</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(
		<span style="color:#a6e22e">pow</span>(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">10</span>),
		<span style="color:#a6e22e">pow</span>(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">20</span>),
	)
}</code></pre></div>
<p>在 <code>if</code> 语句内的短变量声明的变量可用在任意 <code>else</code> 块中使用。</p>

<p>（两次调用pow都会在主要调用fmt.Println之前返回结果。）</p>

<h3 id="exercise-loops-and-functions">Exercise: Loops and Functions</h3>

<p>As a way to play with functions and loops, let&rsquo;s implement a square root function: given a number x, we want to find the number z for which z² is most nearly x.</p>

<p>Computers typically compute the square root of x using a loop. Starting with some guess z, we can adjust z based on how close z² is to x, producing a better guess:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">z</span> <span style="color:#f92672">-=</span> (<span style="color:#a6e22e">z</span><span style="color:#f92672">*</span><span style="color:#a6e22e">z</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">x</span>) <span style="color:#f92672">/</span> (<span style="color:#ae81ff">2</span><span style="color:#f92672">*</span><span style="color:#a6e22e">z</span>)</code></pre></div>
<p>Repeating this adjustment makes the guess better and better until we reach an answer that is as close to the actual square root as can be.</p>

<p>Implement this in the <code>func Sqrt</code> provided. A decent starting guess for z is 1, no matter what the input. To begin with, repeat the calculation 10 times and print each z along the way. See how close you get to the answer for various values of x (1, 2, 3, &hellip;) and how quickly the guess improves.</p>

<p>Hint: To declare and initialize a floating point value, give it floating point syntax or use a conversion:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">z</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1.0</span>
<span style="color:#a6e22e">z</span> <span style="color:#f92672">:=</span> float64(<span style="color:#ae81ff">1</span>)</code></pre></div>
<p>Next, change the loop condition to stop once the value has stopped changing (or only changes by a very small amount). See if that&rsquo;s more or fewer than 10 iterations. Try other initial guesses for z, like x, or x/2. How close are your function&rsquo;s results to the <code>math.Sqrt</code> in the standard library?</p>

<p>(Note: If you are interested in the details of the algorithm, the z² − x above is how far away z² is from where it needs to be (x), and the division by 2z is the derivative of z², to scale how much we adjust z by how quickly z² is changing. This general approach is called Newton&rsquo;s method. It works well for many functions but especially well for square root.)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Sqrt</span>(<span style="color:#a6e22e">x</span> <span style="color:#66d9ef">float64</span>) <span style="color:#66d9ef">float64</span> {
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">Sqrt</span>(<span style="color:#ae81ff">2</span>))
}</code></pre></div>
<p>作为一种使用函数和循环的方式，让我们实现一个平方根函数：给定一个数字 <code>x</code>，我们想找到数字 <code>z</code>，使得 <code>z²</code> 最接近 <code>x</code>.</p>

<p>计算机通常使用循环来计算 x 的平方根。从猜测z开始，我们可以根据 z² 与 x 的接近程度来调整 z，从而得到一个更接近的值：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">z</span> <span style="color:#f92672">-=</span> (<span style="color:#a6e22e">z</span><span style="color:#f92672">*</span><span style="color:#a6e22e">z</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">x</span>) <span style="color:#f92672">/</span> (<span style="color:#ae81ff">2</span><span style="color:#f92672">*</span><span style="color:#a6e22e">z</span>)</code></pre></div>
<p>重复这种调整使得猜测结果越来越好直到我们达到一个尽可能接近实际平方根的答案。</p>

<p>我们在函数 <code>func Sqrt</code> 中实现这些功能。无论输入任何数据，z 最合适的起始猜测值都是 1，。首先重复计算 10 次，并且每次都打印 z 的值。来观察对 x(1, 2, 3, &hellip;) 的各种值你得到的结果有多接近，以及猜测进展的多块。</p>

<p>提示：要声明并初始化一个浮点数，请为其指定浮点语法或使用类型转换：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">z</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1.0</span>
<span style="color:#a6e22e">z</span> <span style="color:#f92672">:=</span> float64(<span style="color:#ae81ff">1</span>)</code></pre></div>
<p>接下来，改变循环条件，使得当值停止改变（或者仅仅改变非常小的量）时循环立即停止。看看是否多于或者少于 10 次迭代。尝试 z 的其他初始猜测，比如 x, x/2。你的函数的结果与 <code>math.Sqrt</code> 标准函数有多接近？</p>

<p>（注意：如果你对算法的细节感兴趣，上面 z² − x 就是 z² 离 （x） 多远，并且除与 2z 是 z² 的导数，根据 z² 增长快慢来决定扩展多少我们调整 z。这种通用方法称为 牛顿法。它适用于许多函数，但特别适用于平方根。）</p>

<h3 id="switch">Switch</h3>

<p>A <code>switch</code> statement is a shorter way to write a sequence of <code>if - else</code> statements. It runs the first case whose value is equal to the condition expression.</p>

<p>Go&rsquo;s switch is like the one in C, C++, Java, JavaScript, and PHP, except that Go only runs the selected case, not all the cases that follow. In effect, the <code>break</code> statement that is needed at the end of each case in those languages is provided automatically in Go. Another important difference is that Go&rsquo;s switch cases need not be constants, and the values involved need not be integers.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;runtime&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Print</span>(<span style="color:#e6db74">&#34;Go runs on &#34;</span>)
	<span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">os</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">runtime</span>.<span style="color:#a6e22e">GOOS</span>; <span style="color:#a6e22e">os</span> {
	<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;darwin&#34;</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;OS X.&#34;</span>)
	<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;linux&#34;</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Linux.&#34;</span>)
	<span style="color:#66d9ef">default</span>:
		<span style="color:#75715e">// freebsd, openbsd,
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// plan9, windows...
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%s.&#34;</span>, <span style="color:#a6e22e">os</span>)
	}
}</code></pre></div>
<p><code>switch</code> 语句是编写 <code>if - else</code> 语句序列的简写形式。它运行第一个值与条件表达式相同的实例。</p>

<p>Go 的 switch 与 C、 C++、 Java、 JavaScript 和 PHP 中的一样，除了 Go 仅仅运行被选中的案例，而不是顺序执行所有的案例。实际上，在这些语言每个案例后面的 <code>break</code> 语句在 Go 中是自动提供的。另外一个重要的区别是 Go 的 switch 案例不一定是常量，所涉及的值也不必是整数。</p>

<h3 id="switch-evaluation-order">Switch evaluation order</h3>

<p>Switch cases evaluate cases from top to bottom, stopping when a case succeeds.</p>

<p>(For example,</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">i</span> {
<span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0</span>:
<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">f</span>():
}</code></pre></div>
<p>does not call <code>f</code> if i==0.)</p>

<p>Note: Time in the Go playground always appears to start at 2009-11-10 23:00:00 UTC, a value whose significance is left as an exercise for the reader.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;time&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;When&#39;s Saturday?&#34;</span>)
	<span style="color:#a6e22e">today</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>().<span style="color:#a6e22e">Weekday</span>()
	<span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Saturday</span> {
	<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">today</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">0</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Today.&#34;</span>)
	<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">today</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Tomorrow.&#34;</span>)
	<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">today</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;In two days.&#34;</span>)
	<span style="color:#66d9ef">default</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Too far away.&#34;</span>)
	}
}</code></pre></div>
<p>Switch 的案例，从上到下评估案例，当案例成功时停止。</p>

<p>(例如，</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">i</span> {
<span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0</span>:
<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">f</span>():
}</code></pre></div>
<p>如果 i==0 则不会调用 <code>f</code>)</p>

<p>注意：在这个 Go 实验环境的时间总是显示为 2009-11-10 23:00:00 UTC，这个值的意义在于留给读者练习。</p>

<h3 id="switch-with-no-condition">Switch with no condition</h3>

<p>Switch without a condition is the same as switch true.</p>

<p>This construct can be a clean way to write long if-then-else chains.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;time&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">t</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>()
	<span style="color:#66d9ef">switch</span> {
	<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Hour</span>() &lt; <span style="color:#ae81ff">12</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Good morning!&#34;</span>)
	<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Hour</span>() &lt; <span style="color:#ae81ff">17</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Good afternoon.&#34;</span>)
	<span style="color:#66d9ef">default</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Good evening.&#34;</span>)
	}
}</code></pre></div>
<p>没有条件的 Switch 相当于 <code>switch true</code>。</p>

<p>这种结构可以作为一个精简的方式来书写很长的 <code>if-then-else</code> 链。</p>

<h3 id="defer">Defer</h3>

<p>A defer statement defers the execution of a function until the surrounding function returns.</p>

<p>The deferred call&rsquo;s arguments are evaluated immediately, but the function call is not executed until the surrounding function returns.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;world&#34;</span>)

	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;hello&#34;</span>)
}</code></pre></div>
<p><code>defer</code> 语句延迟执行函数，直到周围的函数返回。</p>

<p>延迟调用的函数参数会被立即计算出来，但在周围函数返回之前不会执行函数调用。</p>

<h3 id="stacking-defers">Stacking defers</h3>

<p>Deferred function calls are pushed onto a stack. When a function returns, its deferred calls are executed in last-in-first-out order.</p>

<p>To learn more about defer statements read this <a href="https://blog.golang.org/defer-panic-and-recover">blog post</a>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;counting&#34;</span>)

	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">i</span>)
	}

	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;done&#34;</span>)
}</code></pre></div>
<p>延迟函数调用被压入栈中。当函数返回时，其延迟调用以后进先出的顺序执行。</p>

<p>要了解 <code>defer</code> 语句的更多信息，请阅读这篇 <a href="https://blog.golang.org/defer-panic-and-recover">博文</a>.</p>

<h2 id="more-types-structs-slices-and-maps">More types: structs, slices, and maps</h2>

<h3 id="pointers">Pointers</h3>

<p>Go has pointers. A pointer holds the memory address of a value.</p>

<p>The type <code>*T</code> is a pointer to a <code>T</code> value. Its zero value is <code>nil</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">int</span></code></pre></div>
<p>The <code>&amp;</code> operator generates a pointer to its operand.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">42</span>
<span style="color:#a6e22e">p</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">i</span></code></pre></div>
<p>The <code>*</code> operator denotes the pointer&rsquo;s underlying value.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">p</span>) <span style="color:#75715e">// read i through the pointer p
</span><span style="color:#75715e"></span><span style="color:#f92672">*</span><span style="color:#a6e22e">p</span> = <span style="color:#ae81ff">21</span>         <span style="color:#f92672">//</span> <span style="color:#a6e22e">set</span> <span style="color:#a6e22e">i</span> <span style="color:#a6e22e">through</span> <span style="color:#a6e22e">the</span> <span style="color:#a6e22e">pointer</span> <span style="color:#a6e22e">p</span></code></pre></div>
<p>This is known as &ldquo;dereferencing&rdquo; or &ldquo;indirecting&rdquo;.</p>

<p>Unlike C, Go has no pointer arithmetic.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">42</span>, <span style="color:#ae81ff">2701</span>

	<span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">i</span>         <span style="color:#75715e">// point to i
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">p</span>) <span style="color:#75715e">// read i through the pointer
</span><span style="color:#75715e"></span>	<span style="color:#f92672">*</span><span style="color:#a6e22e">p</span> = <span style="color:#ae81ff">21</span>         <span style="color:#75715e">// set i through the pointer
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">i</span>)  <span style="color:#75715e">// see the new value of i
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">p</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">j</span>         <span style="color:#75715e">// point to j
</span><span style="color:#75715e"></span>	<span style="color:#f92672">*</span><span style="color:#a6e22e">p</span> = <span style="color:#f92672">*</span><span style="color:#a6e22e">p</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">37</span>   <span style="color:#75715e">// divide j through the pointer
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">j</span>) <span style="color:#75715e">// see the new value of j
</span><span style="color:#75715e"></span>}</code></pre></div>
<p>Go 语言中有指针，指针保存值的内存地址。</p>

<p>类型 <code>*T</code> 是指向值 <code>T</code> 的指针。它的零值是 <code>nil</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">int</span></code></pre></div>
<p><code>&amp;</code> 运算符生成指向其操作数的指针。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">42</span>
<span style="color:#a6e22e">p</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">i</span></code></pre></div>
<p><code>*</code> 运算符表示指针所指的具体值。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">p</span>) <span style="color:#75715e">// read i through the pointer p
</span><span style="color:#75715e"></span><span style="color:#f92672">*</span><span style="color:#a6e22e">p</span> = <span style="color:#ae81ff">21</span>         <span style="color:#f92672">//</span> <span style="color:#a6e22e">set</span> <span style="color:#a6e22e">i</span> <span style="color:#a6e22e">through</span> <span style="color:#a6e22e">the</span> <span style="color:#a6e22e">pointer</span> <span style="color:#a6e22e">p</span></code></pre></div>
<p>这被称为 “解除引用” 或者 “间接取值”。</p>

<p>不像 C， Go 没有指针算术。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang">	<span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">42</span>, <span style="color:#ae81ff">2701</span>

	<span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">i</span>         <span style="color:#75715e">// point to i
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">q</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">j</span>
	<span style="color:#a6e22e">x</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">q</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">x</span>)</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">prog.go:10:9: invalid operation: p + q <span style="color:#f92672">(</span>operator + not defined on pointer<span style="color:#f92672">)</span>

Go build failed.</code></pre></div>
<h3 id="structs">Structs</h3>

<p>A <code>struct</code> is a collection of fields.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Vertex</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">X</span> <span style="color:#66d9ef">int</span>
	<span style="color:#a6e22e">Y</span> <span style="color:#66d9ef">int</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">Vertex</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>})
}</code></pre></div>
<p><code>struct</code> 是字段的集合。</p>

<h3 id="struct-fields">Struct Fields</h3>

<p>Struct fields are accessed using a dot.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Vertex</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">X</span> <span style="color:#66d9ef">int</span>
	<span style="color:#a6e22e">Y</span> <span style="color:#66d9ef">int</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Vertex</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>}
	<span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">X</span> = <span style="color:#ae81ff">4</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">X</span>)
}</code></pre></div>
<p>使用点访问结构体字段。</p>

<h3 id="pointers-to-structs">Pointers to Structs</h3>

<p>Struct fields can be accessed through a struct pointer.</p>

<p>To access the field <code>X</code> of a struct when we have the struct pointer <code>p</code> we could write <code>(*p).X</code>. However, that notation is cumbersome, so the language permits us instead to write just <code>p.X</code>, without the explicit dereference.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Vertex</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">X</span> <span style="color:#66d9ef">int</span>
	<span style="color:#a6e22e">Y</span> <span style="color:#66d9ef">int</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Vertex</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>}
	<span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">v</span>
	<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">X</span> = <span style="color:#ae81ff">1e9</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">v</span>)
}</code></pre></div>
<p>可以通过结构体指针来访问结构体字段。</p>

<p>当访问一个指针为 <code>p</code> 的结构体的字段 <code>X</code> 是，我们可以写成 <code>(*p).X</code>。然而这种写法是比较臃肿的，所以 Go 允许仅仅书写 <code>p.X</code> 来替代它，而不需要显示解引用。</p>

<h3 id="struct-literals">Struct Literals</h3>

<p>A struct literal denotes a newly allocated struct value by listing the values of its fields.</p>

<p>You can list just a subset of fields by using the Name: syntax. (And the order of named fields is irrelevant.)</p>

<p>The special prefix <code>&amp;</code> returns a pointer to the struct value.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Vertex</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">X</span>, <span style="color:#a6e22e">Y</span> <span style="color:#66d9ef">int</span>
}

<span style="color:#66d9ef">var</span> (
	<span style="color:#a6e22e">v1</span> = <span style="color:#a6e22e">Vertex</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>}  <span style="color:#75715e">// has type Vertex
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">v2</span> = <span style="color:#a6e22e">Vertex</span>{<span style="color:#a6e22e">X</span>: <span style="color:#ae81ff">1</span>}  <span style="color:#75715e">// Y:0 is implicit
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">v3</span> = <span style="color:#a6e22e">Vertex</span>{}      <span style="color:#75715e">// X:0 and Y:0
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">p</span>  = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Vertex</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>} <span style="color:#75715e">// has type *Vertex
</span><span style="color:#75715e"></span>)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">v1</span>, <span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">v2</span>, <span style="color:#a6e22e">v3</span>)
}</code></pre></div>
<p>结构体字面值通过列出其字段的值来表示新分配的结构体的值。</p>

<p>通过使用 <code>Name:</code> 语法，你仅仅可以列出字段子集（并且字段名称的顺序无关紧要。）</p>

<p>特殊前缀 <code>&amp;</code> 返回指向结构体值的指针。</p>

<h3 id="arrays">Arrays</h3>

<p>The type <code>[n]T</code> is an array of <code>n</code> values of type <code>T</code>.</p>

<p>The expression</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> [<span style="color:#ae81ff">10</span>]<span style="color:#66d9ef">int</span></code></pre></div>
<p>declares a variable a as an array of ten integers.</p>

<p>An array&rsquo;s length is part of its type, so arrays cannot be resized. This seems limiting, but don&rsquo;t worry; Go provides a convenient way of working with arrays.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"></code></pre></div>
<p>类型 <code>[n]T</code> 是一个由 <code>n</code> 个 <code>T</code> 类型的值构成的数组。</p>

<p>表达式</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> [<span style="color:#ae81ff">10</span>]<span style="color:#66d9ef">int</span></code></pre></div>
<p>声明了一个 10 个整型数字构成的数组变量 a。</p>

<p>数组的长度是其类型的一部分，因此无法调整数组的大小。这似乎有限制，但不要担心；Go 提供了一种使用数组的便捷方式。</p>

<p>Resize 的数组：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang">	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> [<span style="color:#ae81ff">2</span>]<span style="color:#66d9ef">string</span>
	<span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">0</span>] = <span style="color:#e6db74">&#34;Hello&#34;</span>
	<span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">1</span>] = <span style="color:#e6db74">&#34;World&#34;</span>
		<span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">2</span>] = <span style="color:#e6db74">&#34;Worldxx&#34;</span></code></pre></div>
<p>报错信息：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">prog.go:9:4: invalid array index <span style="color:#ae81ff">2</span> <span style="color:#f92672">(</span>out of bounds <span style="color:#66d9ef">for</span> <span style="color:#ae81ff">2</span>-element array<span style="color:#f92672">)</span>

Go build failed.</code></pre></div>
<h3 id="slices">Slices</h3>

<p>An array has a fixed size. A slice, on the other hand, is a dynamically-sized, flexible view into the elements of an array. In practice, slices are much more common than arrays.</p>

<p>The type <code>[]T</code> is a slice with elements of type <code>T</code>.</p>

<p>A slice is formed by specifying two indices, a low and high bound, separated by a colon:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">low</span> : <span style="color:#a6e22e">high</span>]</code></pre></div>
<p>This selects a half-open range which includes the first element, but excludes the last one.</p>

<p>The following expression creates a slice which includes elements 1 through 3 of a:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">1</span>:<span style="color:#ae81ff">4</span>]</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">primes</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">6</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">13</span>}

	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s</span> []<span style="color:#66d9ef">int</span> = <span style="color:#a6e22e">primes</span>[<span style="color:#ae81ff">1</span>:<span style="color:#ae81ff">4</span>]
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>)
}</code></pre></div>
<p>数组具有固定大小。另一方面，切片是对数组元素的动态大小，灵活的视图。实际上，切片比数组更常见。</p>

<p>类型 <code>[]T</code> 是一个元素为类型 <code>T</code> 的切片。</p>

<p>切片由两个特定的数值格式化，通过指定由冒号分割的低、高两个索引来形成切片。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">low</span> : <span style="color:#a6e22e">high</span>]</code></pre></div>
<p>这种形式选择了一个包含第一个元素，但是不包含最后一个元素的半开区间。</p>

<p>下面的表达式创建了一个包含数组 a 中元素 1 到 3 个元素的切片：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">1</span>:<span style="color:#ae81ff">4</span>]</code></pre></div>
<h3 id="slices-are-like-references-to-arrays">Slices are like references to arrays</h3>

<p>A slice does not store any data, it just describes a section of an underlying array.</p>

<p>Changing the elements of a slice modifies the corresponding elements of its underlying array.</p>

<p>Other slices that share the same underlying array will see those changes.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">names</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">4</span>]<span style="color:#66d9ef">string</span>{
		<span style="color:#e6db74">&#34;John&#34;</span>,
		<span style="color:#e6db74">&#34;Paul&#34;</span>,
		<span style="color:#e6db74">&#34;George&#34;</span>,
		<span style="color:#e6db74">&#34;Ringo&#34;</span>,
	}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">names</span>)

	<span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">names</span>[<span style="color:#ae81ff">0</span>:<span style="color:#ae81ff">2</span>]
	<span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">names</span>[<span style="color:#ae81ff">1</span>:<span style="color:#ae81ff">3</span>]
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span>)

	<span style="color:#a6e22e">b</span>[<span style="color:#ae81ff">0</span>] = <span style="color:#e6db74">&#34;XXX&#34;</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">names</span>)
}</code></pre></div>
<p>切片不存储任何数据，仅仅描述一个底层数组的一部分。</p>

<p>改变切片的元素将修改其底层数组的相应元素。</p>

<p>其它共享此数组的切片将看到这些更改。</p>

<h3 id="slice-literals">Slice literals</h3>

<p>A slice literal is like an array literal without the length.</p>

<p>This is an array literal:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang">[<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">bool</span>{<span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">false</span>}</code></pre></div>
<p>And this creates the same array as above, then builds a slice that references it:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang">[]<span style="color:#66d9ef">bool</span>{<span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">false</span>}</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">q</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">13</span>}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">q</span>)

	<span style="color:#a6e22e">r</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">bool</span>{<span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">false</span>, <span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">false</span>, <span style="color:#66d9ef">true</span>}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">r</span>)

	<span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">struct</span> {
		<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>
		<span style="color:#a6e22e">b</span> <span style="color:#66d9ef">bool</span>
	}{
		{<span style="color:#ae81ff">2</span>, <span style="color:#66d9ef">true</span>},
		{<span style="color:#ae81ff">3</span>, <span style="color:#66d9ef">false</span>},
		{<span style="color:#ae81ff">5</span>, <span style="color:#66d9ef">true</span>},
		{<span style="color:#ae81ff">7</span>, <span style="color:#66d9ef">true</span>},
		{<span style="color:#ae81ff">11</span>, <span style="color:#66d9ef">false</span>},
		{<span style="color:#ae81ff">13</span>, <span style="color:#66d9ef">true</span>},
	}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>)
}</code></pre></div>
<p>切片字面值与数组字面值一样，只不过切片字面值没有长度。</p>

<p>这是一个数组字面值：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang">[<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">bool</span>{<span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">false</span>}</code></pre></div>
<p>创建与上面相同的数组，然后创建一个引用它的切片：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang">[]<span style="color:#66d9ef">bool</span>{<span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">false</span>}</code></pre></div>
<h3 id="slice-defaults">Slice defaults</h3>

<p>When slicing, you may omit the high or low bounds to use their defaults instead.</p>

<p>The default is zero for the low bound and the length of the slice for the high bound.</p>

<p>For the array</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> [<span style="color:#ae81ff">10</span>]<span style="color:#66d9ef">int</span></code></pre></div>
<p>these slice expressions are equivalent:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">0</span>:<span style="color:#ae81ff">10</span>]
<span style="color:#a6e22e">a</span>[:<span style="color:#ae81ff">10</span>]
<span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">0</span>:]
<span style="color:#a6e22e">a</span>[:]</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">13</span>}

	<span style="color:#a6e22e">s</span> = <span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">1</span>:<span style="color:#ae81ff">4</span>]
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>)

	<span style="color:#a6e22e">s</span> = <span style="color:#a6e22e">s</span>[:<span style="color:#ae81ff">2</span>]
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>)

	<span style="color:#a6e22e">s</span> = <span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">1</span>:]
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>)
}</code></pre></div>
<p>切片时，你可以省略上限或者下限而使用其默认值。</p>

<p>下限的默认值为 0，上限的默认值为切片的长度。</p>

<p>对于数组：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> [<span style="color:#ae81ff">10</span>]<span style="color:#66d9ef">int</span></code></pre></div>
<p>这些切片表达式是等价的：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">0</span>:<span style="color:#ae81ff">10</span>]
<span style="color:#a6e22e">a</span>[:<span style="color:#ae81ff">10</span>]
<span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">0</span>:]
<span style="color:#a6e22e">a</span>[:]</code></pre></div>
<h3 id="slice-length-and-capacity">Slice length and capacity</h3>

<p>A slice has both a length and a capacity.</p>

<p>The length of a slice is the number of elements it contains.</p>

<p>The capacity of a slice is the number of elements in the underlying array, counting from the first element in the slice.</p>

<p>The length and capacity of a slice <code>s</code> can be obtained using the expressions <code>len(s)</code> and <code>cap(s)</code>.</p>

<p>You can extend a slice&rsquo;s length by re-slicing it, provided it has sufficient capacity. Try changing one of the slice operations in the example program to extend it beyond its capacity and see what happens.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">13</span>}
	<span style="color:#a6e22e">printSlice</span>(<span style="color:#a6e22e">s</span>)

	<span style="color:#75715e">// Slice the slice to give it zero length.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">s</span> = <span style="color:#a6e22e">s</span>[:<span style="color:#ae81ff">0</span>]
	<span style="color:#a6e22e">printSlice</span>(<span style="color:#a6e22e">s</span>)

	<span style="color:#75715e">// Extend its length.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">s</span> = <span style="color:#a6e22e">s</span>[:<span style="color:#ae81ff">4</span>]
	<span style="color:#a6e22e">printSlice</span>(<span style="color:#a6e22e">s</span>)

	<span style="color:#75715e">// Drop its first two values.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">s</span> = <span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">2</span>:]
	<span style="color:#a6e22e">printSlice</span>(<span style="color:#a6e22e">s</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">printSlice</span>(<span style="color:#a6e22e">s</span> []<span style="color:#66d9ef">int</span>) {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;len=%d cap=%d %v\n&#34;</span>, len(<span style="color:#a6e22e">s</span>), cap(<span style="color:#a6e22e">s</span>), <span style="color:#a6e22e">s</span>)
}</code></pre></div>
<p>切片有长度和容量。</p>

<p>切片的长度是其包含的元素个数。</p>

<p>切片的容量是底层数组从切片第一个元素起计算的元素个数。</p>

<p>可以通过使用表达式 <code>len(s)</code> 和 <code>cap(s)</code> 来获得切片 <code>s</code> 的长度和容量。</p>

<p>只要具有足够多的容量，您可以通过重新切片来扩展一个切片的长度。尝试改变实例中一个切片的操作，将其扩展到超出其容量范围，看看会发生什么。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">panic: runtime error: slice bounds out of range

goroutine <span style="color:#ae81ff">1</span> <span style="color:#f92672">[</span>running<span style="color:#f92672">]</span>:
main.main<span style="color:#f92672">()</span>
	/tmp/sandbox319941102/main.go:18 +0x100</code></pre></div>
<h3 id="nil-slices">Nil slices</h3>

<p>The zero value of a slice is <code>nil</code>.</p>

<p>A nil slice has a length and capacity of 0 and has no underlying array.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s</span> []<span style="color:#66d9ef">int</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>, len(<span style="color:#a6e22e">s</span>), cap(<span style="color:#a6e22e">s</span>))
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;nil!&#34;</span>)
	}
}</code></pre></div>
<p>切片的零值是 <code>nil</code>。</p>

<p>空切片的长度和容量都为 0，且没有底层数组。</p>

<h3 id="creating-a-slice-with-make">Creating a slice with make</h3>

<p>Slices can be created with the built-in <code>make</code> function; this is how you create dynamically-sized arrays.</p>

<p>The <code>make</code> function allocates a zeroed array and returns a slice that refers to that array:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">5</span>)  <span style="color:#f92672">//</span> len(<span style="color:#a6e22e">a</span>)=<span style="color:#ae81ff">5</span></code></pre></div>
<p>To specify a capacity, pass a third argument to <code>make</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">5</span>) <span style="color:#75715e">// len(b)=0, cap(b)=5
</span><span style="color:#75715e"></span>
<span style="color:#a6e22e">b</span> = <span style="color:#a6e22e">b</span>[:cap(<span style="color:#a6e22e">b</span>)] <span style="color:#75715e">// len(b)=5, cap(b)=5
</span><span style="color:#75715e"></span><span style="color:#a6e22e">b</span> = <span style="color:#a6e22e">b</span>[<span style="color:#ae81ff">1</span>:]      <span style="color:#f92672">//</span> len(<span style="color:#a6e22e">b</span>)=<span style="color:#ae81ff">4</span>, cap(<span style="color:#a6e22e">b</span>)=<span style="color:#ae81ff">4</span></code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">5</span>)
	<span style="color:#a6e22e">printSlice</span>(<span style="color:#e6db74">&#34;a&#34;</span>, <span style="color:#a6e22e">a</span>)

	<span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">5</span>)
	<span style="color:#a6e22e">printSlice</span>(<span style="color:#e6db74">&#34;b&#34;</span>, <span style="color:#a6e22e">b</span>)

	<span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">b</span>[:<span style="color:#ae81ff">2</span>]
	<span style="color:#a6e22e">printSlice</span>(<span style="color:#e6db74">&#34;c&#34;</span>, <span style="color:#a6e22e">c</span>)

	<span style="color:#a6e22e">d</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">c</span>[<span style="color:#ae81ff">2</span>:<span style="color:#ae81ff">5</span>]
	<span style="color:#a6e22e">printSlice</span>(<span style="color:#e6db74">&#34;d&#34;</span>, <span style="color:#a6e22e">d</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">printSlice</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">x</span> []<span style="color:#66d9ef">int</span>) {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%s len=%d cap=%d %v\n&#34;</span>,
		<span style="color:#a6e22e">s</span>, len(<span style="color:#a6e22e">x</span>), cap(<span style="color:#a6e22e">x</span>), <span style="color:#a6e22e">x</span>)
}</code></pre></div>
<p>可以使用内置的 <code>make</code> 函数创建切片；这是您创建动态大小数组的方法。</p>

<p><code>make</code> 函数分配一个归零数组并且返回一个引用该数组的切片：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">5</span>)  <span style="color:#f92672">//</span> len(<span style="color:#a6e22e">a</span>)=<span style="color:#ae81ff">5</span></code></pre></div>
<p>要指定切片的容量，请给 <code>make</code> 传递第三个参数：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">5</span>) <span style="color:#75715e">// len(b)=0, cap(b)=5
</span><span style="color:#75715e"></span>
<span style="color:#a6e22e">b</span> = <span style="color:#a6e22e">b</span>[:cap(<span style="color:#a6e22e">b</span>)] <span style="color:#75715e">// len(b)=5, cap(b)=5
</span><span style="color:#75715e"></span><span style="color:#a6e22e">b</span> = <span style="color:#a6e22e">b</span>[<span style="color:#ae81ff">1</span>:]      <span style="color:#f92672">//</span> len(<span style="color:#a6e22e">b</span>)=<span style="color:#ae81ff">4</span>, cap(<span style="color:#a6e22e">b</span>)=<span style="color:#ae81ff">4</span></code></pre></div>
<h3 id="slices-of-slices">Slices of slices</h3>

<p>Slices can contain any type, including other slices.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;strings&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#75715e">// Create a tic-tac-toe board.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">board</span> <span style="color:#f92672">:=</span> [][]<span style="color:#66d9ef">string</span>{
		[]<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;_&#34;</span>, <span style="color:#e6db74">&#34;_&#34;</span>, <span style="color:#e6db74">&#34;_&#34;</span>},
		[]<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;_&#34;</span>, <span style="color:#e6db74">&#34;_&#34;</span>, <span style="color:#e6db74">&#34;_&#34;</span>},
		[]<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;_&#34;</span>, <span style="color:#e6db74">&#34;_&#34;</span>, <span style="color:#e6db74">&#34;_&#34;</span>},
	}

	<span style="color:#75715e">// The players take turns.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">board</span>[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>] = <span style="color:#e6db74">&#34;X&#34;</span>
	<span style="color:#a6e22e">board</span>[<span style="color:#ae81ff">2</span>][<span style="color:#ae81ff">2</span>] = <span style="color:#e6db74">&#34;O&#34;</span>
	<span style="color:#a6e22e">board</span>[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">2</span>] = <span style="color:#e6db74">&#34;X&#34;</span>
	<span style="color:#a6e22e">board</span>[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>] = <span style="color:#e6db74">&#34;O&#34;</span>
	<span style="color:#a6e22e">board</span>[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">2</span>] = <span style="color:#e6db74">&#34;X&#34;</span>

	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">board</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%s\n&#34;</span>, <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Join</span>(<span style="color:#a6e22e">board</span>[<span style="color:#a6e22e">i</span>], <span style="color:#e6db74">&#34; &#34;</span>))
	}
}</code></pre></div>
<p>切片可以包含任何类型，包括其他切片。</p>

<h3 id="appending-to-a-slice">Appending to a slice</h3>

<p>It is common to append new elements to a slice, and so Go provides a built-in <code>append</code> function. The <a href="https://golang.org/pkg/builtin/#append">documentation</a> of the built-in package describes <code>append</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">func</span> append(<span style="color:#a6e22e">s</span> []<span style="color:#a6e22e">T</span>, <span style="color:#a6e22e">vs</span> <span style="color:#f92672">...</span><span style="color:#a6e22e">T</span>) []<span style="color:#a6e22e">T</span></code></pre></div>
<p>The first parameter <code>s</code> of <code>append</code> is a slice of type <code>T</code>, and the rest are <code>T</code> values to append to the slice.</p>

<p>The resulting value of <code>append</code> is a slice containing all the elements of the original slice plus the provided values.</p>

<p>If the backing array of <code>s</code> is too small to fit all the given values a bigger array will be allocated. The returned slice will point to the newly allocated array.</p>

<p>(To learn more about slices, read the <a href="https://blog.golang.org/go-slices-usage-and-internals">Slices: usage and internals</a> article.)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s</span> []<span style="color:#66d9ef">int</span>
	<span style="color:#a6e22e">printSlice</span>(<span style="color:#a6e22e">s</span>)

	<span style="color:#75715e">// append works on nil slices.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">s</span> = append(<span style="color:#a6e22e">s</span>, <span style="color:#ae81ff">0</span>)
	<span style="color:#a6e22e">printSlice</span>(<span style="color:#a6e22e">s</span>)

	<span style="color:#75715e">// The slice grows as needed.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">s</span> = append(<span style="color:#a6e22e">s</span>, <span style="color:#ae81ff">1</span>)
	<span style="color:#a6e22e">printSlice</span>(<span style="color:#a6e22e">s</span>)

	<span style="color:#75715e">// We can add more than one element at a time.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">s</span> = append(<span style="color:#a6e22e">s</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>)
	<span style="color:#a6e22e">printSlice</span>(<span style="color:#a6e22e">s</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">printSlice</span>(<span style="color:#a6e22e">s</span> []<span style="color:#66d9ef">int</span>) {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;len=%d cap=%d %v\n&#34;</span>, len(<span style="color:#a6e22e">s</span>), cap(<span style="color:#a6e22e">s</span>), <span style="color:#a6e22e">s</span>)
}</code></pre></div>
<p>向切片追加新元素是很常见的，为此 Go 提供了一个内置函数 <code>append</code>。内置包<a href="https://golang.org/pkg/builtin/#append">文档</a>描述了 <code>append</code>。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">func</span> append(<span style="color:#a6e22e">s</span> []<span style="color:#a6e22e">T</span>, <span style="color:#a6e22e">vs</span> <span style="color:#f92672">...</span><span style="color:#a6e22e">T</span>) []<span style="color:#a6e22e">T</span></code></pre></div>
<p><code>append</code> 第一个参数 <code>s</code> 是一个类型为 <code>T</code> 的切片，余下的是要追加进切片的类型为 <code>T</code> 的值。</p>

<p><code>append</code> 函数返回的结果是一个包含原始切片所有元素加上追加的元素的一个切片。</p>

<p>如果切片 <code>s</code> 底层的数组太小而无法满足所有给定的值，则会分配一个更大的数组。返回的切片将指向新分配的数组。</p>

<p>(想了解更多关于切片的内容，请参阅文章 <a href="https://blog.golang.org/go-slices-usage-and-internals">Go切片:用法和内部结构</a>。)</p>

<p>运行结果：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">len<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span> cap<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span> <span style="color:#f92672">[]</span>
len<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> cap<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">[</span><span style="color:#ae81ff">0</span><span style="color:#f92672">]</span>
len<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span> cap<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">[</span><span style="color:#ae81ff">0</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">]</span>
len<span style="color:#f92672">=</span><span style="color:#ae81ff">5</span> cap<span style="color:#f92672">=</span><span style="color:#ae81ff">8</span> <span style="color:#f92672">[</span><span style="color:#ae81ff">0</span> <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">4</span><span style="color:#f92672">]</span> <span style="color:#75715e"># 注意最后的容量为 8</span></code></pre></div>
<h3 id="range">Range</h3>

<p>The <code>range</code> form of the <code>for</code> loop iterates over a slice or map.</p>

<p>When ranging over a slice, two values are returned for each iteration. The first is the index, and the second is a copy of the element at that index.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">pow</span> = []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">32</span>, <span style="color:#ae81ff">64</span>, <span style="color:#ae81ff">128</span>}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">pow</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;2**%d = %d\n&#34;</span>, <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">v</span>)
	}
}</code></pre></div>
<p><code>for</code> 循环的 <code>range</code> 迭代切片和映射。</p>

<p>当迭代切片时，每次迭代都会返回两个值。第一个是索引，第二个是该索引处元素的副本。</p>

<h3 id="range-continued">Range continued</h3>

<p>You can skip the index or value by assigning to <code>_</code>.</p>

<p>If you only want the index, drop the <code>,</code> <code>value</code> entirely.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">pow</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">10</span>)
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">pow</span> {
		<span style="color:#a6e22e">pow</span>[<span style="color:#a6e22e">i</span>] = <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> uint(<span style="color:#a6e22e">i</span>) <span style="color:#75715e">// == 2**i
</span><span style="color:#75715e"></span>	}
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">value</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">pow</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%d\n&#34;</span>, <span style="color:#a6e22e">value</span>)
	}
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span><span style="color:#66d9ef">range</span> <span style="color:#a6e22e">pow</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;---&gt;%d\n&#34;</span>, <span style="color:#a6e22e">i</span>)
	}
}</code></pre></div>
<p>您可以通过赋值给 <code>_</code> 来跳过索引 或者 值。</p>

<p>如果你仅仅需要索引，则完全删除 <code>,</code> <code>value</code> 。</p>

<h3 id="exercise-slices">Exercise: Slices</h3>

<p>Implement <code>Pic</code>. It should return a slice of length <code>dy</code>, each element of which is a slice of <code>dx</code> 8-bit unsigned integers. When you run the program, it will display your picture, interpreting the integers as grayscale (well, bluescale) values.</p>

<p>The choice of image is up to you. Interesting functions include <code>(x+y)/2</code>, <code>x*y</code>, and <code>x^y</code>.</p>

<p>(You need to use a loop to allocate each <code>[]uint8</code> inside the <code>[][]uint8</code>.)</p>

<p>(Use <code>uint8(intValue)</code> to convert between types.)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;golang.org/x/tour/pic&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Pic</span>(<span style="color:#a6e22e">dx</span>, <span style="color:#a6e22e">dy</span> <span style="color:#66d9ef">int</span>) [][]<span style="color:#66d9ef">uint8</span> {
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">pic</span>.<span style="color:#a6e22e">Show</span>(<span style="color:#a6e22e">Pic</span>)
}</code></pre></div>
<p>实现函数 <code>Pic</code>. 返回一个长度为 <code>dy</code> 的切片，它的每个元素是一个 <code>dx</code> 8 位无符号整数的切片。当你运行程序，它将展示你的图片，将整数解析为灰度（或者 蓝光）值。</p>

<p>图片的选择取决于您。有趣的函数包含 <code>(x+y)/2</code>， <code>x*y</code>，和 <code>x^y</code>。</p>

<p>(你需要使用循环在 <code>[][]uint8</code> 中分配每个 <code>[]uint8</code>。)</p>

<p>(使用 <code>uint8(intValue)</code> 在类型间进行转换)</p>

<h3 id="maps">Maps</h3>

<p>A map maps keys to values.</p>

<p>The zero value of a map is <code>nil</code>. A <code>nil</code> map has no keys, nor can keys be added.</p>

<p>The <code>make</code> function returns a map of the given type, initialized and ready for use.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Vertex</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">Lat</span>, <span style="color:#a6e22e">Long</span> <span style="color:#66d9ef">float64</span>
}

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">m</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#a6e22e">Vertex</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">m</span> = make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#a6e22e">Vertex</span>)
	<span style="color:#a6e22e">m</span>[<span style="color:#e6db74">&#34;Bell Labs&#34;</span>] = <span style="color:#a6e22e">Vertex</span>{
		<span style="color:#ae81ff">40.68433</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">74.39967</span>,
	}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">m</span>[<span style="color:#e6db74">&#34;Bell Labs&#34;</span>])
}</code></pre></div>
<p>映射将键映射到值。</p>

<p>映射的零值是 <code>nil</code>。<code>nil</code> 映射没有键，也不能添加键（报错：<code>panic: assignment to entry in nil map</code>）。</p>

<p><code>make</code> 函数返回一个给定类型的映射，已初始化并可供使用。</p>

<h3 id="map-literals">Map literals</h3>

<p>Map literals are like struct literals, but the keys are required.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Vertex</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">Lat</span>, <span style="color:#a6e22e">Long</span> <span style="color:#66d9ef">float64</span>
}

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">m</span> = <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#a6e22e">Vertex</span>{
	<span style="color:#e6db74">&#34;Bell Labs&#34;</span>: <span style="color:#a6e22e">Vertex</span>{
		<span style="color:#ae81ff">40.68433</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">74.39967</span>,
	},
	<span style="color:#e6db74">&#34;Google&#34;</span>: <span style="color:#a6e22e">Vertex</span>{
		<span style="color:#ae81ff">37.42202</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">122.08408</span>,
	},
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">m</span>)
	<span style="color:#a6e22e">b</span><span style="color:#f92672">:=</span> <span style="color:#a6e22e">Vertex</span>{<span style="color:#a6e22e">Lat</span>:<span style="color:#ae81ff">222</span>,<span style="color:#a6e22e">Long</span>:<span style="color:#ae81ff">3333</span>}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;\n%v\n&#34;</span>,<span style="color:#a6e22e">b</span>)
	<span style="color:#a6e22e">c</span><span style="color:#f92672">:=</span> <span style="color:#a6e22e">Vertex</span>{<span style="color:#ae81ff">333222</span>,<span style="color:#ae81ff">3223333</span>}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;\n%v\n&#34;</span>,<span style="color:#a6e22e">c</span>)
}</code></pre></div>
<p>映射的字面值跟结构体的字面值一样，但是键是必须的。</p>

<h3 id="map-literals-continued">Map literals continued</h3>

<p>If the top-level type is just a type name, you can omit it from the elements of the literal.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Vertex</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">Lat</span>, <span style="color:#a6e22e">Long</span> <span style="color:#66d9ef">float64</span>
}

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">m</span> = <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#a6e22e">Vertex</span>{
	<span style="color:#e6db74">&#34;Bell Labs&#34;</span>: {<span style="color:#ae81ff">40.68433</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">74.39967</span>},
	<span style="color:#e6db74">&#34;Google&#34;</span>:    {<span style="color:#ae81ff">37.42202</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">122.08408</span>},
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">m</span>)
}</code></pre></div>
<p>如果顶层类型只是一个类型名称，则可以在字面值的元素中省略它。</p>

<h3 id="mutating-maps">Mutating Maps</h3>

<p>Insert or update an element in map <code>m</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">key</span>] = <span style="color:#a6e22e">elem</span></code></pre></div>
<p>Retrieve an element:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">elem</span> = <span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">key</span>]</code></pre></div>
<p>Delete an element:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang">delete(<span style="color:#a6e22e">m</span>, <span style="color:#a6e22e">key</span>)</code></pre></div>
<p>Test that a key is present with a two-value assignment:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">elem</span>, <span style="color:#a6e22e">ok</span> = <span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">key</span>]</code></pre></div>
<p>If <code>key</code> is in <code>m</code>, <code>ok</code> is <code>true</code>. If not, <code>ok</code> is <code>false</code>.</p>

<p>If <code>key</code> is not in the map, then <code>elem</code> is the zero value for the map&rsquo;s element type.</p>

<p>Note: If <code>elem</code> or <code>ok</code> have not yet been declared you could use a short declaration form:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">elem</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">key</span>]</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"></code></pre></div>
<p>在映射 <code>m</code> 中插入或更新映射元素：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">key</span>] = <span style="color:#a6e22e">elem</span></code></pre></div>
<p>检索元素：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">elem</span> = <span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">key</span>]</code></pre></div>
<p>删除元素：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang">delete(<span style="color:#a6e22e">m</span>, <span style="color:#a6e22e">key</span>)</code></pre></div>
<p>使用双值赋值检测键是否存在：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">elem</span>, <span style="color:#a6e22e">ok</span> = <span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">key</span>]</code></pre></div>
<p>如果 <code>key</code> 在 <code>m</code>中，则 <code>ok</code> 为 <code>true</code>。否则，<code>ok</code> 为 <code>false</code>。</p>

<p>如果 <code>key</code> 不在映射中，则 <code>elem</code> 为映射元素类型的零值。</p>

<p>注意：如果 <code>elem</code> 或者 <code>ok</code> 还没有声明，则可用使用短变量声明语句：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">elem</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">key</span>]</code></pre></div>
<h3 id="exercise-maps">Exercise: Maps</h3>

<p>Implement <code>WordCount</code>. It should return a map of the counts of each “word” in the string <code>s</code>. The <code>wc.Test</code> function runs a test suite against the provided function and prints success or failure.</p>

<p>You might find <a href="https://golang.org/pkg/strings/#Fields">strings.Fields</a> helpful.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;golang.org/x/tour/wc&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">WordCount</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">int</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">int</span>{<span style="color:#e6db74">&#34;x&#34;</span>: <span style="color:#ae81ff">1</span>}
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">wc</span>.<span style="color:#a6e22e">Test</span>(<span style="color:#a6e22e">WordCount</span>)
}</code></pre></div>
<p>实现 <code>WordCount</code>。它应该返回字符串 <code>s</code> 中每个 “word”计数的映射。 <code>wc.Test</code> 函数针对提供的函数运行测试套件并打印成功或失败。</p>

<p>你会发现 <a href="https://golang.org/pkg/strings/#Fields">strings.Fields</a> 很有帮助。</p>

<h3 id="function-values">Function values</h3>

<p>Functions are values too. They can be passed around just like other values.</p>

<p>Function values may be used as function arguments and return values.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;math&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">compute</span>(<span style="color:#a6e22e">fn</span> <span style="color:#66d9ef">func</span>(<span style="color:#66d9ef">float64</span>, <span style="color:#66d9ef">float64</span>) <span style="color:#66d9ef">float64</span>) <span style="color:#66d9ef">float64</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fn</span>(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">hypot</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">float64</span>) <span style="color:#66d9ef">float64</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Sqrt</span>(<span style="color:#a6e22e">x</span><span style="color:#f92672">*</span><span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span><span style="color:#f92672">*</span><span style="color:#a6e22e">y</span>)
	}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">hypot</span>(<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">12</span>))

	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">compute</span>(<span style="color:#a6e22e">hypot</span>))
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">compute</span>(<span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Pow</span>))
}</code></pre></div>
<p>函数同样是值。函数可以像其他值那样被传递。</p>

<p>函数值可以用作函数参数和返回值。</p>

<h3 id="function-closures">Function closures</h3>

<p>Go functions may be closures. A closure is a function value that references variables from outside its body. The function may access and assign to the referenced variables; in this sense the function is &ldquo;bound&rdquo; to the variables.</p>

<p>For example, the <code>adder</code> function returns a closure. Each closure is bound to its own <code>sum</code> variable.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">adder</span>() <span style="color:#66d9ef">func</span>(<span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
	<span style="color:#a6e22e">sum</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">x</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
		<span style="color:#a6e22e">sum</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">x</span>
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">sum</span>
	}
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">pos</span>, <span style="color:#a6e22e">neg</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">adder</span>(), <span style="color:#a6e22e">adder</span>()
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(
			<span style="color:#a6e22e">pos</span>(<span style="color:#a6e22e">i</span>),
			<span style="color:#a6e22e">neg</span>(<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span><span style="color:#f92672">*</span><span style="color:#a6e22e">i</span>),
			<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span><span style="color:#f92672">*</span><span style="color:#a6e22e">i</span>,
		)
	}
}</code></pre></div>
<p>Go 函数可能是闭包。闭包是一个函数值，它引用来自其体外的变量。该函数可以对引用的变量进行访问并赋值；在这个意义上，函数绑定到变量。</p>

<p>例如：<code>adder</code> 函数返回一个闭包。每个闭包跟它自己的 <code>sum</code> 变量绑定。</p>

<h3 id="exercise-fibonacci-closure">Exercise: Fibonacci closure</h3>

<p>Let&rsquo;s have some fun with functions.</p>

<p>Implement a <code>fibonacci</code> function that returns a function (a closure) that returns successive <a href="https://en.wikipedia.org/wiki/Fibonacci_number">fibonacci numbers</a> (0, 1, 1, 2, 3, 5, &hellip;).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#75715e">// fibonacci is a function that returns
</span><span style="color:#75715e">// a function that returns an int.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fibonacci</span>() <span style="color:#66d9ef">func</span>() <span style="color:#66d9ef">int</span> {
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">f</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">fibonacci</span>()
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">f</span>())
	}
}</code></pre></div>
<p>让我们对函数有些乐趣。</p>

<p>实现一个 <code>fibonacci</code> 函数，使其返回一个函数（一个闭包），它返回连续<a href="https://en.wikipedia.org/wiki/Fibonacci_number">斐波拉契数</a> (0, 1, 1, 2, 3, 5, …)。</p>

<h1 id="methods-and-interface">Methods and Interface</h1>

<h2 id="methods-and-interfaces">Methods and Interfaces</h2>

<h3 id="methods">Methods</h3>

<p>Go does not have classes. However, you can define methods on types.</p>

<p>A method is a function with a special receiver argument.</p>

<p>The receiver appears in its own argument list between the <code>func</code> keyword and the method name.</p>

<p>In this example, the <code>Abs</code> method has a receiver of type <code>Vertex</code> named <code>v</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;math&#34;</span>
)

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Vertex</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">X</span>, <span style="color:#a6e22e">Y</span> <span style="color:#66d9ef">float64</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">v</span> <span style="color:#a6e22e">Vertex</span>) <span style="color:#a6e22e">Abs</span>() <span style="color:#66d9ef">float64</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Sqrt</span>(<span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">X</span><span style="color:#f92672">*</span><span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">X</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Y</span><span style="color:#f92672">*</span><span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Y</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Vertex</span>{<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Abs</span>())
}</code></pre></div>
<p>Go 没有类。然而，你可以在类型上定义方法。</p>

<p>方法是具有特定接受器参数的函数。</p>

<p>接受器出现在 <code>func</code> 关键字和方法名之间的参数列表中。</p>

<p>本例中，方法 <code>Abs</code> 有一个名为 <code>v</code> 的 <code>Vertex</code> 类型的接受器。</p>

<h3 id="methods-are-functions">Methods are functions</h3>

<p>Remember: a method is just a function with a receiver argument.</p>

<p>Here&rsquo;s <code>Abs</code> written as a regular function with no change in functionality.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;math&#34;</span>
)

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Vertex</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">X</span>, <span style="color:#a6e22e">Y</span> <span style="color:#66d9ef">float64</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Abs</span>(<span style="color:#a6e22e">v</span> <span style="color:#a6e22e">Vertex</span>) <span style="color:#66d9ef">float64</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Sqrt</span>(<span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">X</span><span style="color:#f92672">*</span><span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">X</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Y</span><span style="color:#f92672">*</span><span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Y</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Vertex</span>{<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">Abs</span>(<span style="color:#a6e22e">v</span>))
}</code></pre></div>
<p>请记住：方法是一个带有接收器参数的函数。</p>

<p>这里 <code>Abs</code> 作为常规函数编写，功能上没有什么变化。</p>

<h3 id="methods-continued">Methods continued</h3>

<p>You can declare a method on non-struct types, too.</p>

<p>In this example we see a numeric type <code>MyFloat</code> with an <code>Abs</code> method.</p>

<p>You can only declare a method with a receiver whose type is defined in the same package as the method. You cannot declare a method with a receiver whose type is defined in another package (which includes the built-in types such as <code>int</code>).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;math&#34;</span>
)

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">MyFloat</span> <span style="color:#66d9ef">float64</span>

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">f</span> <span style="color:#a6e22e">MyFloat</span>) <span style="color:#a6e22e">Abs</span>() <span style="color:#66d9ef">float64</span> {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">f</span> &lt; <span style="color:#ae81ff">0</span> {
		<span style="color:#66d9ef">return</span> float64(<span style="color:#f92672">-</span><span style="color:#a6e22e">f</span>)
	}
	<span style="color:#66d9ef">return</span> float64(<span style="color:#a6e22e">f</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">f</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">MyFloat</span>(<span style="color:#f92672">-</span><span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Sqrt2</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">f</span>.<span style="color:#a6e22e">Abs</span>())
}</code></pre></div>
<p>你也可以在非结构体类型上声明方法。</p>

<p>本例中，我们看到一个带有方法 <code>Abs</code> 的数据类型 <code>MyFloat</code>。</p>

<p>你仅可以在类型声明的包中声明包含接收器的方法。你不能使用接收器声明一个方法，该类型在另一个包中定义（包括内置的类型比如 <code>int</code>）。</p>

<h3 id="pointer-receivers">Pointer receivers</h3>

<p>You can declare methods with pointer receivers.</p>

<p>This means the receiver type has the literal syntax <code>*T</code> for some type <code>T</code>. (Also, <code>T</code> cannot itself be a pointer such as <code>*int</code>.)</p>

<p>For example, the <code>Scale</code> method here is defined on <code>*Vertex</code>.</p>

<p>Methods with pointer receivers can modify the value to which the receiver points (as <code>Scale</code> does here). Since methods often need to modify their receiver, pointer receivers are more common than value receivers.</p>

<p>Try removing the <code>*</code> from the declaration of the <code>Scale</code> function on line 16 and observe how the program&rsquo;s behavior changes.</p>

<p>With a value receiver, the <code>Scale</code> method operates on a copy of the original <code>Vertex</code> value. (This is the same behavior as for any other function argument.) The <code>Scale</code> method must have a pointer receiver to change the <code>Vertex</code> value declared in the <code>main</code> function.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;math&#34;</span>
)

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Vertex</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">X</span>, <span style="color:#a6e22e">Y</span> <span style="color:#66d9ef">float64</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">v</span> <span style="color:#a6e22e">Vertex</span>) <span style="color:#a6e22e">Abs</span>() <span style="color:#66d9ef">float64</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Sqrt</span>(<span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">X</span><span style="color:#f92672">*</span><span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">X</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Y</span><span style="color:#f92672">*</span><span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Y</span>)
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">v</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Vertex</span>) <span style="color:#a6e22e">Scale</span>(<span style="color:#a6e22e">f</span> <span style="color:#66d9ef">float64</span>) {
	<span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">X</span> = <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">X</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">f</span>
	<span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Y</span> = <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Y</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">f</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Vertex</span>{<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>}
	<span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Scale</span>(<span style="color:#ae81ff">10</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Abs</span>())
}</code></pre></div>
<p>您可以使用指针接收器声明方法。</p>

<p>这意味着接收器类型对于某些类型 <code>T</code> 具有文字语法 <code>*T</code>。（此外， <code>T</code> 本身不能是诸如 <code>*int</code> 这样的指针。）</p>

<p>例如，此处的 <code>Scale</code> 方法在 <code>*Vertex</code> 上定义。</p>

<p>具有指针接收器的方法可以修改指针接收器所指向的值（如此处 <code>Scale</code> 所示）。由于方法通常需要修改其接收器，因此指针接收器要比值接收器更常见些。</p>

<p>尝试去除第 16 行 <code>Scale</code> 函数声明中的 <code>*</code> 并观察程序行为的变化。</p>

<p>使用值接收器， <code>Scale</code> 方法对原始 <code>Vertex</code> 值的副本进行操作。（这种行为与其他任何函数参数的行为相同。） <code>Scale</code> 方法必须有一个指针接收器来更改 <code>main</code> 函数中声明的 <code>Vertex</code> 的值。</p>

<h3 id="pointers-and-functions">Pointers and functions</h3>

<p>Here we see the <code>Abs</code> and <code>Scale</code> methods rewritten as functions.</p>

<p>Again, try removing the <code>*</code> from line 16. Can you see why the behavior changes? What else did you need to change for the example to compile?</p>

<p>(If you&rsquo;re not sure, continue to the next page.)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;math&#34;</span>
)

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Vertex</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">X</span>, <span style="color:#a6e22e">Y</span> <span style="color:#66d9ef">float64</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Abs</span>(<span style="color:#a6e22e">v</span> <span style="color:#a6e22e">Vertex</span>) <span style="color:#66d9ef">float64</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Sqrt</span>(<span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">X</span><span style="color:#f92672">*</span><span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">X</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Y</span><span style="color:#f92672">*</span><span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Y</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Scale</span>(<span style="color:#a6e22e">v</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Vertex</span>, <span style="color:#a6e22e">f</span> <span style="color:#66d9ef">float64</span>) {
	<span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">X</span> = <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">X</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">f</span>
	<span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Y</span> = <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Y</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">f</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Vertex</span>{<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>}
	<span style="color:#a6e22e">Scale</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">v</span>, <span style="color:#ae81ff">10</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">Abs</span>(<span style="color:#a6e22e">v</span>))
}</code></pre></div>
<p>在这里，我们看到方法 <code>Abs</code> 和 <code>Scale</code> 都被重写为函数。</p>

<p>再次尝试去掉第 16 行的 <code>*</code>。你能看出行为发生变化的原因吗？还有什么需要改变这个例子才能编译过去？</p>

<p>（如果你还不确定，请先继续下一页）</p>

<h3 id="methods-and-pointer-indirection">Methods and pointer indirection</h3>

<p>Comparing the previous two programs, you might notice that functions with a pointer argument must take a pointer:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">v</span> <span style="color:#a6e22e">Vertex</span>
<span style="color:#a6e22e">ScaleFunc</span>(<span style="color:#a6e22e">v</span>, <span style="color:#ae81ff">5</span>)  <span style="color:#75715e">// Compile error!
</span><span style="color:#75715e"></span><span style="color:#a6e22e">ScaleFunc</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">v</span>, <span style="color:#ae81ff">5</span>) <span style="color:#f92672">//</span> <span style="color:#a6e22e">OK</span></code></pre></div>
<p>while methods with pointer receivers take either a value or a pointer as the receiver when they are called:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">v</span> <span style="color:#a6e22e">Vertex</span>
<span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Scale</span>(<span style="color:#ae81ff">5</span>)  <span style="color:#75715e">// OK
</span><span style="color:#75715e"></span><span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">v</span>
<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">Scale</span>(<span style="color:#ae81ff">10</span>) <span style="color:#f92672">//</span> <span style="color:#a6e22e">OK</span></code></pre></div>
<p>For the statement <code>v.Scale(5)</code>, even though <code>v</code> is a value and not a pointer, the method with the pointer receiver is called automatically. That is, as a convenience, Go interprets the statement <code>v.Scale(5)</code> as <code>(&amp;v).Scale(5)</code> since the <code>Scale</code> method has a pointer receiver.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Vertex</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">X</span>, <span style="color:#a6e22e">Y</span> <span style="color:#66d9ef">float64</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">v</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Vertex</span>) <span style="color:#a6e22e">Scale</span>(<span style="color:#a6e22e">f</span> <span style="color:#66d9ef">float64</span>) {
	<span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">X</span> = <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">X</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">f</span>
	<span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Y</span> = <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Y</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">f</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">ScaleFunc</span>(<span style="color:#a6e22e">v</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Vertex</span>, <span style="color:#a6e22e">f</span> <span style="color:#66d9ef">float64</span>) {
	<span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">X</span> = <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">X</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">f</span>
	<span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Y</span> = <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Y</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">f</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Vertex</span>{<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>}
	<span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Scale</span>(<span style="color:#ae81ff">2</span>)
	<span style="color:#a6e22e">ScaleFunc</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">v</span>, <span style="color:#ae81ff">10</span>)

	<span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Vertex</span>{<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">3</span>}
	<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">Scale</span>(<span style="color:#ae81ff">3</span>)
	<span style="color:#a6e22e">ScaleFunc</span>(<span style="color:#a6e22e">p</span>, <span style="color:#ae81ff">8</span>)

	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">p</span>)
}</code></pre></div>
<p>对比前两个程序，你可能会注意到，带有指针参数的函数必须使用指针：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">v</span> <span style="color:#a6e22e">Vertex</span>
<span style="color:#a6e22e">ScaleFunc</span>(<span style="color:#a6e22e">v</span>, <span style="color:#ae81ff">5</span>)  <span style="color:#75715e">// Compile error!
</span><span style="color:#75715e"></span><span style="color:#a6e22e">ScaleFunc</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">v</span>, <span style="color:#ae81ff">5</span>) <span style="color:#f92672">//</span> <span style="color:#a6e22e">OK</span></code></pre></div>
<p>然而，带有指针接收器的方法，调用时使用值或者指针作为指针接收器：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">v</span> <span style="color:#a6e22e">Vertex</span>
<span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Scale</span>(<span style="color:#ae81ff">5</span>)  <span style="color:#75715e">// OK
</span><span style="color:#75715e"></span><span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">v</span>
<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">Scale</span>(<span style="color:#ae81ff">10</span>) <span style="color:#f92672">//</span> <span style="color:#a6e22e">OK</span></code></pre></div>
<p>对于语句 <code>v.Scale(5)</code>，即使 <code>v</code> 是值而非指针，也会自动调用携带指针接收器的方法。即，为了方便，Go 解析语句 <code>v.Scale(5)</code> 为 <code>(&amp;v).Scale(5)</code> 尽管 <code>Scale</code> 方法携带指针接收器。</p>

<h3 id="methods-and-pointer-indirection-2">Methods and pointer indirection(2)</h3>

<p>The equivalent thing happens in the reverse direction.</p>

<p>Functions that take a value argument must take a value of that specific type:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">v</span> <span style="color:#a6e22e">Vertex</span>
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">AbsFunc</span>(<span style="color:#a6e22e">v</span>))  <span style="color:#75715e">// OK
</span><span style="color:#75715e"></span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">AbsFunc</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">v</span>)) <span style="color:#f92672">//</span> <span style="color:#a6e22e">Compile</span> <span style="color:#66d9ef">error</span>!</code></pre></div>
<p>while methods with value receivers take either a value or a pointer as the receiver when they are called:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">v</span> <span style="color:#a6e22e">Vertex</span>
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Abs</span>()) <span style="color:#75715e">// OK
</span><span style="color:#75715e"></span><span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">v</span>
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">Abs</span>()) <span style="color:#f92672">//</span> <span style="color:#a6e22e">OK</span></code></pre></div>
<p>In this case, the method call <code>p.Abs()</code> is interpreted as <code>(*p).Abs()</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;math&#34;</span>
)

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Vertex</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">X</span>, <span style="color:#a6e22e">Y</span> <span style="color:#66d9ef">float64</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">v</span> <span style="color:#a6e22e">Vertex</span>) <span style="color:#a6e22e">Abs</span>() <span style="color:#66d9ef">float64</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Sqrt</span>(<span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">X</span><span style="color:#f92672">*</span><span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">X</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Y</span><span style="color:#f92672">*</span><span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Y</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">AbsFunc</span>(<span style="color:#a6e22e">v</span> <span style="color:#a6e22e">Vertex</span>) <span style="color:#66d9ef">float64</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Sqrt</span>(<span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">X</span><span style="color:#f92672">*</span><span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">X</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Y</span><span style="color:#f92672">*</span><span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Y</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Vertex</span>{<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Abs</span>())
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">AbsFunc</span>(<span style="color:#a6e22e">v</span>))

	<span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Vertex</span>{<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">3</span>}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">Abs</span>())
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">AbsFunc</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">p</span>))
}</code></pre></div>
<p>同样的事情发生在相反的方向。</p>

<p>带有值参数的函数必须传入特定类型的值：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">v</span> <span style="color:#a6e22e">Vertex</span>
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">AbsFunc</span>(<span style="color:#a6e22e">v</span>))  <span style="color:#75715e">// OK
</span><span style="color:#75715e"></span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">AbsFunc</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">v</span>)) <span style="color:#f92672">//</span> <span style="color:#a6e22e">Compile</span> <span style="color:#66d9ef">error</span>!</code></pre></div>
<p>而具有接收器的方法调用将值或者指针作为接收器：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">v</span> <span style="color:#a6e22e">Vertex</span>
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Abs</span>()) <span style="color:#75715e">// OK
</span><span style="color:#75715e"></span><span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">v</span>
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">Abs</span>()) <span style="color:#f92672">//</span> <span style="color:#a6e22e">OK</span></code></pre></div>
<p>这种情况下，方法调用 <code>p.Abs()</code> 解释为 <code>(*p).Abs()</code>。</p>

<h3 id="choosing-a-value-or-pointer-receiver">Choosing a value or pointer receiver</h3>

<p>There are two reasons to use a pointer receiver.</p>

<p>The first is so that the method can modify the value that its receiver points to.</p>

<p>The second is to avoid copying the value on each method call. This can be more efficient if the receiver is a large struct, for example.</p>

<p>In this example, both <code>Scale</code> and <code>Abs</code> are with receiver type <code>*Vertex</code>, even though the <code>Abs</code> method needn&rsquo;t modify its receiver.</p>

<p>In general, all methods on a given type should have either value or pointer receivers, but not a mixture of both. (We&rsquo;ll see why over the next few pages.)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;math&#34;</span>
)

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Vertex</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">X</span>, <span style="color:#a6e22e">Y</span> <span style="color:#66d9ef">float64</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">v</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Vertex</span>) <span style="color:#a6e22e">Scale</span>(<span style="color:#a6e22e">f</span> <span style="color:#66d9ef">float64</span>) {
	<span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">X</span> = <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">X</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">f</span>
	<span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Y</span> = <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Y</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">f</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">v</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Vertex</span>) <span style="color:#a6e22e">Abs</span>() <span style="color:#66d9ef">float64</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Sqrt</span>(<span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">X</span><span style="color:#f92672">*</span><span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">X</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Y</span><span style="color:#f92672">*</span><span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Y</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Vertex</span>{<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Before scaling: %+v, Abs: %v\n&#34;</span>, <span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Abs</span>())
	<span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Scale</span>(<span style="color:#ae81ff">5</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;After scaling: %+v, Abs: %v\n&#34;</span>, <span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Abs</span>())
}</code></pre></div>
<p>使用指针接收器有两种原因。</p>

<p>第一个是这个方法可以更改其接收器所指向的值。</p>

<p>第二是避免在每次方法调用时拷贝值（接收器的所指向的值）。如果接收器是一个很大的结构体，则这可以更高效，例如：</p>

<p>在本例中，<code>Scale</code> 和 <code>Abs</code> 都具有 <code>*Vertex</code> 类型的接收器，即使方法 <code>Abs</code> 不需要更改它的接收器。</p>

<p>通常，给定类型的所有方法都应该具有值或指针接收器，但不能将两者混用。（我们将在后面几页看到原因。）</p>

<h3 id="interfaces">Interfaces</h3>

<p>An interface type is defined as a set of method signatures.</p>

<p>A value of interface type can hold any value that implements those methods.</p>

<p>Note: There is an error in the example code on line 22. <code>Vertex</code> (the value type) doesn&rsquo;t implement <code>Abser</code> because the <code>Abs</code> method is defined only on <code>*Vertex</code> (the pointer type).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;math&#34;</span>
)

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Abser</span> <span style="color:#66d9ef">interface</span> {
	<span style="color:#a6e22e">Abs</span>() <span style="color:#66d9ef">float64</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> <span style="color:#a6e22e">Abser</span>
	<span style="color:#a6e22e">f</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">MyFloat</span>(<span style="color:#f92672">-</span><span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Sqrt2</span>)
	<span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Vertex</span>{<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>}

	<span style="color:#a6e22e">a</span> = <span style="color:#a6e22e">f</span>  <span style="color:#75715e">// a MyFloat implements Abser
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">a</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">v</span> <span style="color:#75715e">// a *Vertex implements Abser
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">// In the following line, v is a Vertex (not *Vertex)
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// and does NOT implement Abser.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">a</span> = <span style="color:#a6e22e">v</span>

	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">Abs</span>())
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">MyFloat</span> <span style="color:#66d9ef">float64</span>

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">f</span> <span style="color:#a6e22e">MyFloat</span>) <span style="color:#a6e22e">Abs</span>() <span style="color:#66d9ef">float64</span> {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">f</span> &lt; <span style="color:#ae81ff">0</span> {
		<span style="color:#66d9ef">return</span> float64(<span style="color:#f92672">-</span><span style="color:#a6e22e">f</span>)
	}
	<span style="color:#66d9ef">return</span> float64(<span style="color:#a6e22e">f</span>)
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Vertex</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">X</span>, <span style="color:#a6e22e">Y</span> <span style="color:#66d9ef">float64</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">v</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Vertex</span>) <span style="color:#a6e22e">Abs</span>() <span style="color:#66d9ef">float64</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Sqrt</span>(<span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">X</span><span style="color:#f92672">*</span><span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">X</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Y</span><span style="color:#f92672">*</span><span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Y</span>)
}</code></pre></div>
<p>接口类型定义为一组方法签名。</p>

<p>接口类型的值可以包含实现了这些方法的任何值。</p>

<p>注意：实例中第 22 行存在错误。<code>Vertex</code> （值类型）未实现 <code>Abser</code> 方法，因为方法 <code>Abs</code> 仅在<code>*Vertex</code> 上定义（指针类型）。</p>

<h3 id="interfaces-are-implemented-implicitly">Interfaces are implemented implicitly</h3>

<p>A type implements an interface by implementing its methods. There is no explicit declaration of intent, no &ldquo;implements&rdquo; keyword.</p>

<p>Implicit interfaces decouple the definition of an interface from its implementation, which could then appear in any package without prearrangement.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">I</span> <span style="color:#66d9ef">interface</span> {
	<span style="color:#a6e22e">M</span>()
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">T</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">S</span> <span style="color:#66d9ef">string</span>
}

<span style="color:#75715e">// This method means type T implements the interface I,
</span><span style="color:#75715e">// but we don&#39;t need to explicitly declare that it does so.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">t</span> <span style="color:#a6e22e">T</span>) <span style="color:#a6e22e">M</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">S</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#a6e22e">I</span> = <span style="color:#a6e22e">T</span>{<span style="color:#e6db74">&#34;hello&#34;</span>}
	<span style="color:#a6e22e">i</span>.<span style="color:#a6e22e">M</span>()
}</code></pre></div>
<p>类型通过实现其方法来实现接口。没有显式的意图声明，没有 &ldquo;implements&rdquo; 关键字。</p>

<p>隐式接口将接口的定义与其实现分离，然后可以在没有预先安排的情况下出现在任何包中。</p>

<h3 id="interface-values">Interface values</h3>

<p>Under the hood, interface values can be thought of as a tuple of a value and a concrete type:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang">(<span style="color:#a6e22e">value</span>, <span style="color:#66d9ef">type</span>)</code></pre></div>
<p>An interface value holds a value of a specific underlying concrete type.</p>

<p>Calling a method on an interface value executes the method of the same name on its underlying type.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;math&#34;</span>
)

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">I</span> <span style="color:#66d9ef">interface</span> {
	<span style="color:#a6e22e">M</span>()
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">T</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">S</span> <span style="color:#66d9ef">string</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">T</span>) <span style="color:#a6e22e">M</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">S</span>)
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">F</span> <span style="color:#66d9ef">float64</span>

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">f</span> <span style="color:#a6e22e">F</span>) <span style="color:#a6e22e">M</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">f</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#a6e22e">I</span>

	<span style="color:#a6e22e">i</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">T</span>{<span style="color:#e6db74">&#34;Hello&#34;</span>}
	<span style="color:#a6e22e">describe</span>(<span style="color:#a6e22e">i</span>)
	<span style="color:#a6e22e">i</span>.<span style="color:#a6e22e">M</span>()

	<span style="color:#a6e22e">i</span> = <span style="color:#a6e22e">F</span>(<span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Pi</span>)
	<span style="color:#a6e22e">describe</span>(<span style="color:#a6e22e">i</span>)
	<span style="color:#a6e22e">i</span>.<span style="color:#a6e22e">M</span>()
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">describe</span>(<span style="color:#a6e22e">i</span> <span style="color:#a6e22e">I</span>) {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;(%v, %T)\n&#34;</span>, <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">i</span>)
}</code></pre></div>
<p>底层，接口值可以被看做是值与具体类型的元组：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang">(<span style="color:#a6e22e">value</span>, <span style="color:#66d9ef">type</span>)</code></pre></div>
<p>接口值保存着特定底层具体类型的值。</p>

<p>在接口值上调用方法，执行与底层类型同名的方法。</p>

<p>实例运行结果：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">(</span>&amp;<span style="color:#f92672">{</span>Hello<span style="color:#f92672">}</span>, *main.T<span style="color:#f92672">)</span>
Hello
<span style="color:#f92672">(</span><span style="color:#ae81ff">3</span>.141592653589793, main.F<span style="color:#f92672">)</span>
<span style="color:#ae81ff">3</span>.141592653589793</code></pre></div>
<h3 id="interface-values-with-nil-underlying-values">Interface values with nil underlying values</h3>

<p>If the concrete value inside the interface itself is nil, the method will be called with a nil receiver.</p>

<p>In some languages this would trigger a null pointer exception, but in Go it is common to write methods that gracefully handle being called with a nil receiver (as with the method <code>M</code> in this example.)</p>

<p>Note that an interface value that holds a nil concrete value is itself non-nil.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">I</span> <span style="color:#66d9ef">interface</span> {
	<span style="color:#a6e22e">M</span>()
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">T</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">S</span> <span style="color:#66d9ef">string</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">T</span>) <span style="color:#a6e22e">M</span>() {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">t</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;&lt;nil&gt;&#34;</span>)
		<span style="color:#66d9ef">return</span>
	}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">S</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#a6e22e">I</span>

	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">T</span>
	<span style="color:#a6e22e">i</span> = <span style="color:#a6e22e">t</span>
	<span style="color:#a6e22e">describe</span>(<span style="color:#a6e22e">i</span>)
	<span style="color:#a6e22e">i</span>.<span style="color:#a6e22e">M</span>()

	<span style="color:#a6e22e">i</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">T</span>{<span style="color:#e6db74">&#34;hello&#34;</span>}
	<span style="color:#a6e22e">describe</span>(<span style="color:#a6e22e">i</span>)
	<span style="color:#a6e22e">i</span>.<span style="color:#a6e22e">M</span>()
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">describe</span>(<span style="color:#a6e22e">i</span> <span style="color:#a6e22e">I</span>) {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;(%v, %T)\n&#34;</span>, <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">i</span>)
}</code></pre></div>
<p>如果接口内部的具体的值为 nil，则使用 nil 接收器调用该方法。</p>

<p>在某些编程语言中，这会触发空指针异常，但在 Go 语言中，通常会编写优雅的处理使用 nil 接收器调用的方法。（与本例中的 <code>M</code> 方法一样。）</p>

<p>注意，保存具体值为 nil 的接口值本身是非空的。</p>

<p>实例运行结果：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">(</span>&lt;nil&gt;, *main.T<span style="color:#f92672">)</span>
&lt;nil&gt;
<span style="color:#f92672">(</span>&amp;<span style="color:#f92672">{</span>hello<span style="color:#f92672">}</span>, *main.T<span style="color:#f92672">)</span>
hello</code></pre></div>
<h3 id="nil-interface-values">Nil interface values</h3>

<p>A nil interface value holds neither value nor concrete type.</p>

<p>Calling a method on a nil interface is a run-time error because there is no type inside the interface tuple to indicate which concrete method to call.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">I</span> <span style="color:#66d9ef">interface</span> {
	<span style="color:#a6e22e">M</span>()
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#a6e22e">I</span>
	<span style="color:#a6e22e">describe</span>(<span style="color:#a6e22e">i</span>)
	<span style="color:#a6e22e">i</span>.<span style="color:#a6e22e">M</span>()
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">describe</span>(<span style="color:#a6e22e">i</span> <span style="color:#a6e22e">I</span>) {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;(%v, %T)\n&#34;</span>, <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">i</span>)
}</code></pre></div>
<p>空接口值既不包含值也不包含具体类型。</p>

<p>在 nil 接口上调用方法是一个运行时错误，因为接口元组中没有类型来指示要调用哪个具体的方法。</p>

<p>实例运行报错信息：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">(</span>&lt;nil&gt;, &lt;nil&gt;<span style="color:#f92672">)</span>
panic: runtime error: invalid memory address or nil pointer dereference
<span style="color:#f92672">[</span>signal SIGSEGV: segmentation violation code<span style="color:#f92672">=</span>0xffffffff addr<span style="color:#f92672">=</span>0x0 pc<span style="color:#f92672">=</span>0xd5ee4<span style="color:#f92672">]</span>

goroutine <span style="color:#ae81ff">1</span> <span style="color:#f92672">[</span>running<span style="color:#f92672">]</span>:
main.main<span style="color:#f92672">()</span>
	/tmp/sandbox649504136/main.go:12 +0x24

Program exited: status <span style="color:#ae81ff">2</span>.</code></pre></div>
<h3 id="the-empty-interface">The empty interface</h3>

<p>The interface type that specifies zero methods is known as the empty interface:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">interface</span>{}</code></pre></div>
<p>An empty interface may hold values of any type. (Every type implements at least zero methods.)</p>

<p>Empty interfaces are used by code that handles values of unknown type. For example, <code>fmt.Print</code> takes any number of arguments of type <code>interface{}</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#66d9ef">interface</span>{}
	<span style="color:#a6e22e">describe</span>(<span style="color:#a6e22e">i</span>)

	<span style="color:#a6e22e">i</span> = <span style="color:#ae81ff">42</span>
	<span style="color:#a6e22e">describe</span>(<span style="color:#a6e22e">i</span>)

	<span style="color:#a6e22e">i</span> = <span style="color:#e6db74">&#34;hello&#34;</span>
	<span style="color:#a6e22e">describe</span>(<span style="color:#a6e22e">i</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">describe</span>(<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">interface</span>{}) {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;(%v, %T)\n&#34;</span>, <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">i</span>)
}</code></pre></div>
<p>指定零个方法的接口类型称为空接口：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">interface</span>{}</code></pre></div>
<p>空接口可以保存任何类型的值。（每个类型至少实现 0 个方法。）</p>

<p>空接口被用来在代码中处理未知类型值。例如， <code>fmt.Print</code> 接收任意数量的 <code>interface{}</code> 类型参数。</p>

<h3 id="type-assertions">Type assertions</h3>

<p>A type assertion provides access to an interface value&rsquo;s underlying concrete value.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">t</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">i</span>.(<span style="color:#a6e22e">T</span>)</code></pre></div>
<p>This statement asserts that the interface value <code>i</code> holds the concrete type <code>T</code> and assigns the underlying <code>T</code> value to the variable <code>t</code>.</p>

<p>If <code>i</code> does not hold a <code>T</code>, the statement will trigger a panic.</p>

<p>To test whether an interface value holds a specific type, a type assertion can return two values: the underlying value and a boolean value that reports whether the assertion succeeded.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">t</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">i</span>.(<span style="color:#a6e22e">T</span>)</code></pre></div>
<p>If <code>i</code> holds a <code>T</code>, then <code>t</code> will be the underlying value and <code>ok</code> will be true.</p>

<p>If not, <code>ok</code> will be false and <code>t</code> will be the zero value of type <code>T</code>, and no panic occurs.</p>

<p>Note the similarity between this syntax and that of reading from a map.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#66d9ef">interface</span>{} = <span style="color:#e6db74">&#34;hello&#34;</span>

	<span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">i</span>.(<span style="color:#66d9ef">string</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>)

	<span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">i</span>.(<span style="color:#66d9ef">string</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">ok</span>)

	<span style="color:#a6e22e">f</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">i</span>.(<span style="color:#66d9ef">float64</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">f</span>, <span style="color:#a6e22e">ok</span>)

	<span style="color:#a6e22e">f</span> = <span style="color:#a6e22e">i</span>.(<span style="color:#66d9ef">float64</span>) <span style="color:#75715e">// panic
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">f</span>)
}</code></pre></div>
<p>类型断言提供对接口值底层具体值的访问。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">t</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">i</span>.(<span style="color:#a6e22e">T</span>)</code></pre></div>
<p>该语句断言接口值 <code>i</code> 保存的具体类型为 <code>T</code>，并将 <code>T</code> 底层的值赋值给变量 <code>t</code>。</p>

<p>如果 <code>i</code> 没有保存着 <code>T</code>，该语句将引发运行时恐慌。</p>

<p>要测试接口值是否包含特定类型，类型断言可以返回两个值：底层值以及一个报告断言是否成功的布尔值。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">t</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">i</span>.(<span style="color:#a6e22e">T</span>)</code></pre></div>
<p>如果 <code>i</code> 持有 <code>T</code>，则 <code>t</code> 将是其底层的值，且 <code>ok</code> 值为 true。</p>

<p>否则，<code>ok</code> 值为 false 且 <code>t</code> 将赋为类型 <code>T</code> 的零值，且不会引发运行时恐慌。</p>

<p>注意，跟这种语法类似的是读取一个映射。</p>

<p>实例运行结果及错误如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">hello
hello true
<span style="color:#ae81ff">0</span> false
panic: interface conversion: interface <span style="color:#f92672">{}</span> is string, not float64

goroutine <span style="color:#ae81ff">1</span> <span style="color:#f92672">[</span>running<span style="color:#f92672">]</span>:
main.main<span style="color:#f92672">()</span>
	/tmp/sandbox038380101/main.go:17 +0x220

Program exited: status <span style="color:#ae81ff">2</span>.</code></pre></div>
<h3 id="type-switches">Type switches</h3>

<p>A type switch is a construct that permits several type assertions in series.</p>

<p>A type switch is like a regular switch statement, but the cases in a type switch specify types (not values), and those values are compared against the type of the value held by the given interface value.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">i</span>.(<span style="color:#66d9ef">type</span>) {
<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">T</span>:
    <span style="color:#75715e">// here v has type T
</span><span style="color:#75715e"></span><span style="color:#66d9ef">case</span> <span style="color:#a6e22e">S</span>:
    <span style="color:#75715e">// here v has type S
</span><span style="color:#75715e"></span><span style="color:#66d9ef">default</span>:
    <span style="color:#75715e">// no match; here v has the same type as i
</span><span style="color:#75715e"></span>}</code></pre></div>
<p>The declaration in a type switch has the same syntax as a type assertion <code>i.(T)</code>, but the specific type <code>T</code> is replaced with the keyword <code>type</code>.</p>

<p>This switch statement tests whether the interface value <code>i</code> holds a value of type <code>T</code> or <code>S</code>. In each of the <code>T</code> and <code>S</code> cases, the variable <code>v</code> will be of type <code>T</code> or <code>S</code> respectively and hold the value held by <code>i</code>. In the default case (where there is no match), the variable <code>v</code> is of the same interface type and value as <code>i</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">do</span>(<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">interface</span>{}) {
	<span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">i</span>.(<span style="color:#66d9ef">type</span>) {
	<span style="color:#66d9ef">case</span> <span style="color:#66d9ef">int</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Twice %v is %v\n&#34;</span>, <span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">v</span><span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>)
	<span style="color:#66d9ef">case</span> <span style="color:#66d9ef">string</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%q is %v bytes long\n&#34;</span>, <span style="color:#a6e22e">v</span>, len(<span style="color:#a6e22e">v</span>))
	<span style="color:#66d9ef">default</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;I don&#39;t know about type %T!\n&#34;</span>, <span style="color:#a6e22e">v</span>)
	}
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">do</span>(<span style="color:#ae81ff">21</span>)
	<span style="color:#a6e22e">do</span>(<span style="color:#e6db74">&#34;hello&#34;</span>)
	<span style="color:#a6e22e">do</span>(<span style="color:#66d9ef">true</span>)
}</code></pre></div>
<p>类型开关是一种允许串联多种类型断言的结构。</p>

<p>类型开关语句类似于常规 <code>switch</code> 语句，但是类型开关中的情况指定类型（而不是值），且将这些值与给定接口值所持有的值的类型进行比较。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">i</span>.(<span style="color:#66d9ef">type</span>) {
<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">T</span>:
    <span style="color:#75715e">// here v has type T
</span><span style="color:#75715e"></span><span style="color:#66d9ef">case</span> <span style="color:#a6e22e">S</span>:
    <span style="color:#75715e">// here v has type S
</span><span style="color:#75715e"></span><span style="color:#66d9ef">default</span>:
    <span style="color:#75715e">// no match; here v has the same type as i
</span><span style="color:#75715e"></span>}</code></pre></div>
<p>类型开关的声明与类型断言的语法相同如同 <code>i.(T)</code>，但特定类型 <code>T</code> 被替换为 <code>type</code> 关键字。</p>

<p>此开关语句测试接口值 <code>i</code> 是否包含类型 <code>T</code> 或 <code>S</code> 的值。在每个 <code>T</code> 和 <code>S</code> 案例中，变量 <code>v</code> 将分别是类型 <code>T</code> 或者 <code>S</code> 且保存着被变量 <code>i</code> 保存的值。在默认的案例中（没有匹配），变量 <code>v</code> 与 <code>i</code> 有相同的接口类型和值。</p>

<h3 id="stringers">Stringers</h3>

<p>One of the most ubiquitous interfaces is <code>Stringer</code> defined by the <code>fmt</code> package.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Stringer</span> <span style="color:#66d9ef">interface</span> {
    <span style="color:#a6e22e">String</span>() <span style="color:#66d9ef">string</span>
}</code></pre></div>
<p>A <code>Stringer</code> is a type that can describe itself as a string. The <code>fmt</code> package (and many others) look for this interface to print values.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Person</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">Name</span> <span style="color:#66d9ef">string</span>
	<span style="color:#a6e22e">Age</span>  <span style="color:#66d9ef">int</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#a6e22e">Person</span>) <span style="color:#a6e22e">String</span>() <span style="color:#66d9ef">string</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;%v (%v years)&#34;</span>, <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">Name</span>, <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">Age</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Person</span>{<span style="color:#e6db74">&#34;Arthur Dent&#34;</span>, <span style="color:#ae81ff">42</span>}
	<span style="color:#a6e22e">z</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Person</span>{<span style="color:#e6db74">&#34;Zaphod Beeblebrox&#34;</span>, <span style="color:#ae81ff">9001</span>}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">z</span>)
}</code></pre></div>
<p>有个最常见的接口是由 <code>fmt</code> 包定义的 <code>Stringer</code>。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Stringer</span> <span style="color:#66d9ef">interface</span> {
    <span style="color:#a6e22e">String</span>() <span style="color:#66d9ef">string</span>
}</code></pre></div>
<p><code>Stringer</code> 是一种可以将自己描述为字符串的类型。<code>fmt</code> 包（以及许多其它包）查找这个接口来打印它们的值。</p>

<h3 id="exercise-stringers">Exercise: Stringers</h3>

<p>Make the <code>IPAddr</code> type implement <code>fmt.Stringer</code> to print the address as a dotted quad.</p>

<p>For instance, <code>IPAddr{1, 2, 3, 4}</code> should print as <code>”1.2.3.4”</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">IPAddr</span> [<span style="color:#ae81ff">4</span>]<span style="color:#66d9ef">byte</span>

<span style="color:#75715e">// TODO: Add a &#34;String() string&#34; method to IPAddr.
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">hosts</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#a6e22e">IPAddr</span>{
		<span style="color:#e6db74">&#34;loopback&#34;</span>:  {<span style="color:#ae81ff">127</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>},
		<span style="color:#e6db74">&#34;googleDNS&#34;</span>: {<span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">8</span>},
	}
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">name</span>, <span style="color:#a6e22e">ip</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">hosts</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%v: %v\n&#34;</span>, <span style="color:#a6e22e">name</span>, <span style="color:#a6e22e">ip</span>)
	}
}</code></pre></div>
<p>使 <code>IPAddr</code> 类型实现 <code>fmt.Stringer</code> 来按点四打印地址。</p>

<p>例如，<code>IPAddr{1, 2, 3, 4}</code> 应该打印为 <code>”1.2.3.4”</code>。</p>

<h3 id="errors">Errors</h3>

<p>Go programs express error state with <code>error</code> values.</p>

<p>The <code>error</code> type is a built-in interface similar to <code>fmt.Stringer</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">type</span> <span style="color:#66d9ef">error</span> <span style="color:#66d9ef">interface</span> {
    <span style="color:#a6e22e">Error</span>() <span style="color:#66d9ef">string</span>
}</code></pre></div>
<p>(As with <code>fmt.Stringer</code>, the <code>fmt</code> package looks for the <code>error</code> interface when printing values.)</p>

<p>Functions often return an <code>error</code> value, and calling code should handle errors by testing whether the error equals <code>nil</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">Atoi</span>(<span style="color:#e6db74">&#34;42&#34;</span>)
<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;couldn&#39;t convert number: %v\n&#34;</span>, <span style="color:#a6e22e">err</span>)
    <span style="color:#66d9ef">return</span>
}
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Converted integer:&#34;</span>, <span style="color:#a6e22e">i</span>)</code></pre></div>
<p>A nil <code>error</code> denotes success; a non-nil <code>error</code> denotes failure.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;time&#34;</span>
)

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">MyError</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">When</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Time</span>
	<span style="color:#a6e22e">What</span> <span style="color:#66d9ef">string</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">e</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">MyError</span>) <span style="color:#a6e22e">Error</span>() <span style="color:#66d9ef">string</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;at %v, %s&#34;</span>,
		<span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">When</span>, <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">What</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">run</span>() <span style="color:#66d9ef">error</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">MyError</span>{
		<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>(),
		<span style="color:#e6db74">&#34;it didn&#39;t work&#34;</span>,
	}
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">run</span>(); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">err</span>)
	}
}</code></pre></div>
<p>Go 程序使用 <code>error</code> 值表达错误状态。</p>

<p><code>error</code> 类型是内置接口，与 <code>fmt.Stringer</code>类似：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">type</span> <span style="color:#66d9ef">error</span> <span style="color:#66d9ef">interface</span> {
    <span style="color:#a6e22e">Error</span>() <span style="color:#66d9ef">string</span>
}</code></pre></div>
<p>（与 <code>fmt.Stringer</code> 一样，<code>fmt</code> 包在打印值时会查找 <code>error</code> 接口。）</p>

<p>函数通常返回 <code>error</code> 值，调用的代码应该通过测试错误值是否等于 <code>nil</code> 来处理错误。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">Atoi</span>(<span style="color:#e6db74">&#34;42&#34;</span>)
<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;couldn&#39;t convert number: %v\n&#34;</span>, <span style="color:#a6e22e">err</span>)
    <span style="color:#66d9ef">return</span>
}
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Converted integer:&#34;</span>, <span style="color:#a6e22e">i</span>)</code></pre></div>
<p>空 <code>error</code> 表示成功；非空 <code>error</code> 表示失败。</p>

<h3 id="exercise-errors">Exercise: Errors</h3>

<p>Copy your <code>Sqrt</code> function from the <a href="https://tour.golang.org/flowcontrol/8">earlier exercise</a> and modify it to return an <code>error</code> value.</p>

<p><code>Sqrt</code> should return a non-nil error value when given a negative number, as it doesn&rsquo;t support complex numbers.</p>

<p>Create a new type</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ErrNegativeSqrt</span> <span style="color:#66d9ef">float64</span></code></pre></div>
<p>and make it an error by giving it a</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">e</span> <span style="color:#a6e22e">ErrNegativeSqrt</span>) <span style="color:#a6e22e">Error</span>() <span style="color:#66d9ef">string</span></code></pre></div>
<p>method such that <code>ErrNegativeSqrt(-2).Error()</code> returns <code>”cannot Sqrt negative number: -2&quot;</code>.</p>

<p>Note: A call to <code>fmt.Sprint(e)</code> inside the <code>Error</code> method will send the program into an infinite loop. You can avoid this by converting <code>e</code> first: <code>fmt.Sprint(float64(e))</code>. Why?</p>

<p>Change your <code>Sqrt</code> function to return an <code>ErrNegativeSqrt</code> value when given a negative number.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Sqrt</span>(<span style="color:#a6e22e">x</span> <span style="color:#66d9ef">float64</span>) (<span style="color:#66d9ef">float64</span>, <span style="color:#66d9ef">error</span>) {
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">nil</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">Sqrt</span>(<span style="color:#ae81ff">2</span>))
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">Sqrt</span>(<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>))
}</code></pre></div>
<p>从你<a href="https://tour.golang.org/flowcontrol/8">早先的练习</a> 中复制函数 <code>Sqrt</code> 并修改它以返回错误值。</p>

<p>当传入一个负数时 <code>Sqrt</code> 应该返回非空的错误值，因为其不支持复数。</p>

<p>创建一个新类型</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ErrNegativeSqrt</span> <span style="color:#66d9ef">float64</span></code></pre></div>
<p>且通过给它一个方法诸如调用 <code>ErrNegativeSqrt(-2).Error()</code> 返回 <code>”cannot Sqrt negative number: -2&quot;</code>，使其成为一个错误。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">e</span> <span style="color:#a6e22e">ErrNegativeSqrt</span>) <span style="color:#a6e22e">Error</span>() <span style="color:#66d9ef">string</span></code></pre></div>
<p>注意：在 <code>Error</code> 方法中调用 <code>fmt.Sprint(e)</code> 会将程序带入无限循环中。可以通过首先把 <code>e</code> 进行类型转换：<code>fmt.Sprint(float64(e))</code> 来避免。为什么？</p>

<p>改变你的 <code>Sqrt</code> 函数，使得当传入一个负数时返回 <code>ErrNegativeSqrt</code> 值。</p>

<p>练习修改及错误输出：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;errors&#34;</span>
)

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ErrNegativeSqrt</span> <span style="color:#66d9ef">float64</span>

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">e</span> <span style="color:#a6e22e">ErrNegativeSqrt</span>) <span style="color:#a6e22e">Error</span>() <span style="color:#66d9ef">string</span> {
	<span style="color:#75715e">//return &#34;cannot Sqrt negative number: &#34; + fmt.Sprint(float64(e))
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;cannot Sqrt negative number: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprint</span>(<span style="color:#a6e22e">e</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Sqrt</span>(<span style="color:#a6e22e">x</span> <span style="color:#66d9ef">float64</span>) (<span style="color:#66d9ef">float64</span>, <span style="color:#66d9ef">error</span>) {
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">New</span>(<span style="color:#a6e22e">ErrNegativeSqrt</span>(<span style="color:#a6e22e">x</span>).<span style="color:#a6e22e">Error</span>())
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">Sqrt</span>(<span style="color:#ae81ff">2</span>))
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">Sqrt</span>(<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>))
}</code></pre></div>
<p>少部分错误输出：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">runtime: goroutine stack exceeds <span style="color:#ae81ff">250000000</span>-byte limit
fatal error: stack overflow

runtime stack:
runtime.throw<span style="color:#f92672">(</span>0xfff9f, 0xe<span style="color:#f92672">)</span>
	/usr/local/go/src/runtime/panic.go:608 +0x80
runtime.newstack<span style="color:#f92672">()</span>
	/usr/local/go/src/runtime/stack.go:1008 +0x9c0
runtime.morestack<span style="color:#f92672">()</span>
	/usr/local/go/src/runtime/asm_amd64p32.s:299 +0xc0

goroutine <span style="color:#ae81ff">1</span> <span style="color:#f92672">[</span>running<span style="color:#f92672">]</span>:
sync.<span style="color:#f92672">(</span>*Pool<span style="color:#f92672">)</span>.Get<span style="color:#f92672">(</span>0x19d0f0, 0x1a45a0, 0xfefc0000, 0x0<span style="color:#f92672">)</span>
	/usr/local/go/src/sync/pool.go:124 +0x200 fp<span style="color:#f92672">=</span>0x8800370 sp<span style="color:#f92672">=</span>0x8800368 pc<span style="color:#f92672">=</span>0x98b80
fmt.newPrinter<span style="color:#f92672">(</span>0x0, 0x0<span style="color:#f92672">)</span>
	/usr/local/go/src/fmt/print.go:133 +0x40 fp<span style="color:#f92672">=</span>0x8800388 sp<span style="color:#f92672">=</span>0x8800370 pc<span style="color:#f92672">=</span>0xcb1a0
fmt.Sprint<span style="color:#f92672">(</span>0x88003d8, 0x1, 0x1, 0x40000000, 0xef900, 0x4818bc0<span style="color:#f92672">)</span>
	/usr/local/go/src/fmt/print.go:238 +0x20 fp<span style="color:#f92672">=</span>0x88003b8 sp<span style="color:#f92672">=</span>0x8800388 pc<span style="color:#f92672">=</span>0xcb720
main.ErrNegativeSqrt.Error<span style="color:#f92672">(</span>0x0, 0x40000000, 0xeed64018, 0x8800404<span style="color:#f92672">)</span></code></pre></div>
<h3 id="readers">Readers</h3>

<p>The <code>io</code> package specifies the <code>io.Reader</code> interface, which represents the read end of a stream of data.</p>

<p>The Go standard library contains <a href="https://golang.org/search?q=Read#Global">many implementations</a> of these interfaces, including files, network connections, compressors, ciphers, and others.</p>

<p>The <code>io.Reader</code> interface has a Read method:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">T</span>) <span style="color:#a6e22e">Read</span>(<span style="color:#a6e22e">b</span> []<span style="color:#66d9ef">byte</span>) (<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>)</code></pre></div>
<p><code>Read</code> populates the given byte slice with data and returns the number of bytes populated and an error value. It returns an <code>io.EOF</code> error when the stream ends.</p>

<p>The example code creates a <code>strings.Reader</code> and consumes its output 8 bytes at a time.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;io&#34;</span>
	<span style="color:#e6db74">&#34;strings&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">r</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">NewReader</span>(<span style="color:#e6db74">&#34;Hello, Reader!&#34;</span>)

	<span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">byte</span>, <span style="color:#ae81ff">8</span>)
	<span style="color:#66d9ef">for</span> {
		<span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Read</span>(<span style="color:#a6e22e">b</span>)
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;n = %v err = %v b = %v\n&#34;</span>, <span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">err</span>, <span style="color:#a6e22e">b</span>)
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;b[:n] = %q\n&#34;</span>, <span style="color:#a6e22e">b</span>[:<span style="color:#a6e22e">n</span>])
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">EOF</span> {
			<span style="color:#66d9ef">break</span>
		}
	}
}</code></pre></div>
<p><code>io</code> 包含有 <code>io.Reader</code> 接口，它表示数据流的读取结束。</p>

<p>Go 标准库包含这些接口的<a href="https://golang.org/search?q=Read#Global">许多实现</a>，包括文件、网络连接、压缩器、密码等。</p>

<p><code>io.Reader</code> 接口有个读方法：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">T</span>) <span style="color:#a6e22e">Read</span>(<span style="color:#a6e22e">b</span> []<span style="color:#66d9ef">byte</span>) (<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>)</code></pre></div>
<p><code>Read</code> 用数据填充给定的字节切片并返回已经填充的字节数与错误值。当被处理的流结束时，它返回 <code>io.EOF</code> 错误。</p>

<p>示例代码中创建了一个每次消费其 8 个字节输出的 <code>strings.Reader</code>。</p>

<h3 id="exercise-readers">Exercise:Readers</h3>

<p>Implement a <code>Reader</code> type that emits an infinite stream of the ASCII character <code>’A’</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;golang.org/x/tour/reader&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">MyReader</span> <span style="color:#66d9ef">struct</span>{}

<span style="color:#75715e">// TODO: Add a Read([]byte) (int, error) method to MyReader.
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">reader</span>.<span style="color:#a6e22e">Validate</span>(<span style="color:#a6e22e">MyReader</span>{})
}</code></pre></div>
<p>实现一个发出 ASSCII 字符 <code>’A’</code> 的无限流的 <code>Reader</code> 类型。</p>

<h3 id="exercise-rot13reader">Exercise: rot13Reader</h3>

<p>A common pattern is an <a href="https://golang.org/pkg/io/#Reader">io.Reader</a> that wraps another <code>io.Reader</code>, modifying the stream in some way.</p>

<p>For example, the <a href="https://golang.org/pkg/compress/gzip/#NewReader">gzip.NewReader</a> function takes an <code>io.Reader</code> (a stream of compressed data) and returns a <code>*gzip.Reader</code> that also implements <code>io.Reader</code> (a stream of the decompressed data).</p>

<p>Implement a <code>rot13Reader</code> that implements <code>io.Reader</code> and reads from an <code>io.Reader</code>, modifying the stream by applying the <a href="https://en.wikipedia.org/wiki/ROT13">rot13</a> substitution cipher to all alphabetical characters.</p>

<p>The <code>rot13Reader</code> type is provided for you. Make it an <code>io.Reader</code> by implementing its <code>Read</code> method.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;io&#34;</span>
	<span style="color:#e6db74">&#34;os&#34;</span>
	<span style="color:#e6db74">&#34;strings&#34;</span>
)

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">rot13Reader</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">r</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Reader</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">NewReader</span>(<span style="color:#e6db74">&#34;Lbh penpxrq gur pbqr!&#34;</span>)
	<span style="color:#a6e22e">r</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">rot13Reader</span>{<span style="color:#a6e22e">s</span>}
	<span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Copy</span>(<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Stdout</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">r</span>)
}</code></pre></div>
<p>常见的模式是一个 <a href="https://golang.org/pkg/io/#Reader">io.Reader</a> 包装另一个 <code>io.Reader</code>，以某种方式更新流。</p>

<p>例如，<a href="https://golang.org/pkg/compress/gzip/#NewReader">gzip.NewReader</a> 函数接受一个 <code>io.Reader</code> (一个压缩数据流) 并返回一个同样实现了 <code>io.Reader</code>（一个解压缩数据流）的 <code>*gzip.Reader</code>。</p>

<p>实现一个实现了 <code>io.Reader</code> 的 <code>rot13Reader</code>，并从 <code>io.Reader</code> 读取，并请求 <a href="https://en.wikipedia.org/wiki/ROT13">rot13</a>替换密码应用于所有字母来修改流。</p>

<p><code>rot13Reader</code> 类型已经为你提供好了。通过实现其 <code>Read</code> 方法使其成为 <code>io.Reader</code>。</p>

<h3 id="images">Images</h3>

<p><a href="https://golang.org/pkg/image/#Image">Package image</a> defines the <code>Image</code> interface:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">image</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Image</span> <span style="color:#66d9ef">interface</span> {
    <span style="color:#a6e22e">ColorModel</span>() <span style="color:#a6e22e">color</span>.<span style="color:#a6e22e">Model</span>
    <span style="color:#a6e22e">Bounds</span>() <span style="color:#a6e22e">Rectangle</span>
    <span style="color:#a6e22e">At</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>) <span style="color:#a6e22e">color</span>.<span style="color:#a6e22e">Color</span>
}</code></pre></div>
<p>Note: the <code>Rectangle</code> return value of the <code>Bounds</code> method is actually an <code>image.Rectangle</code>, as the declaration is inside package <code>image</code>.</p>

<p>(See <a href="https://golang.org/pkg/image/#Image">the documentation</a> for all the details.)</p>

<p>The <code>color.Color</code> and <code>color.Model</code> types are also interfaces, but we&rsquo;ll ignore that by using the predefined implementations <code>color.RGBA</code> and <code>color.RGBAModel</code>. These interfaces and types are specified by the <a href="https://golang.org/pkg/image/color/">image/color package</a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;image&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">image</span>.<span style="color:#a6e22e">NewRGBA</span>(<span style="color:#a6e22e">image</span>.<span style="color:#a6e22e">Rect</span>(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">100</span>))
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Bounds</span>())
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">At</span>(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>).<span style="color:#a6e22e">RGBA</span>())
}</code></pre></div>
<p><a href="https://golang.org/pkg/image/#Image">image 包</a> 定义了 <code>Image</code> 接口：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">image</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Image</span> <span style="color:#66d9ef">interface</span> {
    <span style="color:#a6e22e">ColorModel</span>() <span style="color:#a6e22e">color</span>.<span style="color:#a6e22e">Model</span>
    <span style="color:#a6e22e">Bounds</span>() <span style="color:#a6e22e">Rectangle</span>
    <span style="color:#a6e22e">At</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>) <span style="color:#a6e22e">color</span>.<span style="color:#a6e22e">Color</span>
}</code></pre></div>
<p>注意：<code>Bounds</code> 方法的 <code>Rectangle</code> 返回值实际是一个 <code>image.Rectangle</code>，因为声明在 <code>image</code> 包中。</p>

<p>（所有相关详细信息，请参阅<a href="https://golang.org/pkg/image/#Image">文档</a>）</p>

<p><code>color.Color</code> 和 <code>color.Model</code> 类型也是接口，但是我们将通过使用预定义的实现 <code>color.RGBA</code> 和 <code>color.RGBAModel</code> 来忽略它。这些接口和类型都是 <a href="https://golang.org/pkg/image/color/">image/color 包</a>中的。</p>

<h3 id="exercise-images">Exercise:Images</h3>

<p>Remember the <a href="https://tour.golang.org/moretypes/18">picture generator</a> you wrote earlier? Let&rsquo;s write another one, but this time it will return an implementation of <code>image.Image</code> instead of a slice of data.</p>

<p>Define your own <code>Image</code> type, implement <a href="https://golang.org/pkg/image/#Image">the necessary methods</a>, and call <code>pic.ShowImage</code>.</p>

<p><code>Bounds</code> should return a <code>image.Rectangle</code>, like <code>image.Rect(0, 0, w, h)</code>.</p>

<p><code>ColorModel</code> should return <code>color.RGBAModel</code>.</p>

<p><code>At</code> should return a color; the value <code>v</code> in the last picture generator corresponds to <code>color.RGBA{v, v, 255, 255}</code> in this one.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;golang.org/x/tour/pic&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Image</span> <span style="color:#66d9ef">struct</span>{}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Image</span>{}
	<span style="color:#a6e22e">pic</span>.<span style="color:#a6e22e">ShowImage</span>(<span style="color:#a6e22e">m</span>)
}</code></pre></div>
<p>还记得你之前编写过的<a href="https://tour.golang.org/moretypes/18">图片生成器</a> 吗？让我们再写一个，但这次它将返回 <code>image.Image</code> 的实现而不是一个数据切片。</p>

<p>定义你自己的 <code>Image</code> 类型，实现<a href="https://golang.org/pkg/image/#Image">必要的方法</a>且调用<code>pic.ShowImage</code>。</p>

<p><code>Bounds</code> 应该返回一个 <code>image.Rectangle</code>，比如 <code>image.Rect(0, 0, w, h)</code>。</p>

<p><code>ColorModel</code> 应该返回 <code>color.RGBAModel</code>。</p>

<p><code>At</code> 应该返回一种颜色，最后一个图片生成器中的值 <code>v</code> 对应于 <code>color.RGBA{v, v, 255, 255}</code>。</p>

<h1 id="concurrency">Concurrency</h1>

<h2 id="concurrency-1">Concurrency</h2>

<h3 id="goroutines">Goroutines</h3>

<p>A goroutine is a lightweight thread managed by the Go runtime.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">go</span> <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">z</span>)</code></pre></div>
<p>starts a new goroutine running</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">z</span>)</code></pre></div>
<p>The evaluation of <code>f</code>, <code>x</code>, <code>y</code>, and <code>z</code> happens in the current goroutine and the execution of <code>f</code> happens in the new goroutine.</p>

<p>Goroutines run in the same address space, so access to shared memory must be synchronized. The <code>sync</code> package provides useful primitives, although you won&rsquo;t need them much in Go as there are other primitives. (See the next slide.)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;time&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">say</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>) {
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">5</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#ae81ff">100</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Millisecond</span>)
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>)
	}
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">say</span>(<span style="color:#e6db74">&#34;world&#34;</span>)
	<span style="color:#a6e22e">say</span>(<span style="color:#e6db74">&#34;hello&#34;</span>)
}</code></pre></div>
<p>协程是一个由 Go 运行时管理的轻量级线程。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">go</span> <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">z</span>)</code></pre></div>
<p>开始一个新的协程运行</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">z</span>)</code></pre></div>
<p><code>f</code>，<code>x</code>， <code>y</code>，和 <code>z</code> 的计算发生在当前协程中，而 <code>f</code> 的执行，发生在新的协程。</p>

<p>协程运行在相同的地址空间中，因此必须同步对共享内存的访问。<code>sync</code> 包提供了有用的原语，尽管在 Go 中不需要它们，因为还有其它原语。（查看下一页幻灯片）</p>

<h3 id="channels">Channels</h3>

<p>Channels are a typed conduit through which you can send and receive values with the channel operator, <code>&lt;-</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">v</span>    <span style="color:#75715e">// Send v to channel ch.
</span><span style="color:#75715e"></span><span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch</span>  <span style="color:#75715e">// Receive from ch, and
</span><span style="color:#75715e"></span>           <span style="color:#f92672">//</span> <span style="color:#a6e22e">assign</span> <span style="color:#a6e22e">value</span> <span style="color:#a6e22e">to</span> <span style="color:#a6e22e">v</span>.</code></pre></div>
<p>(The data flows in the direction of the arrow.)</p>

<p>Like maps and slices, channels must be created before use:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)</code></pre></div>
<p>By default, sends and receives block until the other side is ready. This allows goroutines to synchronize without explicit locks or condition variables.</p>

<p>The example code sums the numbers in a slice, distributing the work between two goroutines. Once both goroutines have completed their computation, it calculates the final result.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sum</span>(<span style="color:#a6e22e">s</span> []<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">c</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#a6e22e">sum</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">s</span> {
		<span style="color:#a6e22e">sum</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">v</span>
	}
	<span style="color:#a6e22e">c</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">sum</span> <span style="color:#75715e">// send sum to c
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">8</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">0</span>}

	<span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">sum</span>(<span style="color:#a6e22e">s</span>[:len(<span style="color:#a6e22e">s</span>)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>], <span style="color:#a6e22e">c</span>)
	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">sum</span>(<span style="color:#a6e22e">s</span>[len(<span style="color:#a6e22e">s</span>)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>:], <span style="color:#a6e22e">c</span>)
	<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">c</span>, <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">c</span> <span style="color:#75715e">// receive from c
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">x</span><span style="color:#f92672">+</span><span style="color:#a6e22e">y</span>)
}</code></pre></div>
<p>Channels 是一种类型化的管道，通过它可以使用通道运算符 <code>&lt;-</code> 来发送和接受值。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">v</span>    <span style="color:#75715e">// Send v to channel ch.
</span><span style="color:#75715e"></span><span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch</span>  <span style="color:#75715e">// Receive from ch, and
</span><span style="color:#75715e"></span>           <span style="color:#f92672">//</span> <span style="color:#a6e22e">assign</span> <span style="color:#a6e22e">value</span> <span style="color:#a6e22e">to</span> <span style="color:#a6e22e">v</span>.</code></pre></div>
<p>（数据在箭头方向流动。）</p>

<p>与映射和切片类似，channels 也必须先创建后使用：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)</code></pre></div>
<p>默认情况下，发送和接受阻塞，直到另一侧准备好。这允许协程可以不需要显式加锁或者条件变量的情况下进行同步。</p>

<p>实例代码对切片中的数字进行求和，将工作在两个协程间分派。两个协程都完成它们的计算后，它将求出最终结果。</p>

<h3 id="buffered-channels">Buffered Channels</h3>

<p>Channels can be buffered. Provide the buffer length as the second argument to <code>make</code> to initialize a buffered channel:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">100</span>)</code></pre></div>
<p>Sends to a buffered channel block only when the buffer is full. Receives block when the buffer is empty.</p>

<p>Modify the example to overfill the buffer and see what happens.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">2</span>)
	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">1</span>
	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">2</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch</span>)
}</code></pre></div>
<p>通道可以缓冲。给 <code>make</code> 方法提供第二个参数作为缓冲长度将初始化一个缓冲通道：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">100</span>)</code></pre></div>
<p>向缓冲通道发送数据，仅当缓冲都填满后它才会阻塞。当缓冲都空了后接收才会阻塞。</p>

<p>修改示例，将缓冲溢出看看会发生什么。</p>

<p>修改：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">2</span>)
	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">1</span>
	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">2</span>
	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">33</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch</span>)
}</code></pre></div>
<p>报错：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">fatal</span> <span style="color:#66d9ef">error</span>: <span style="color:#a6e22e">all</span> <span style="color:#a6e22e">goroutines</span> <span style="color:#a6e22e">are</span> <span style="color:#a6e22e">asleep</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">deadlock</span>!

<span style="color:#a6e22e">goroutine</span> <span style="color:#ae81ff">1</span> [<span style="color:#66d9ef">chan</span> <span style="color:#a6e22e">send</span>]:
<span style="color:#a6e22e">main</span>.<span style="color:#a6e22e">main</span>()
	<span style="color:#f92672">/</span><span style="color:#a6e22e">tmp</span><span style="color:#f92672">/</span><span style="color:#a6e22e">sandbox432591258</span><span style="color:#f92672">/</span><span style="color:#a6e22e">main</span>.<span style="color:#66d9ef">go</span>:<span style="color:#ae81ff">9</span> <span style="color:#f92672">+</span><span style="color:#ae81ff">0xa0</span>

<span style="color:#a6e22e">Program</span> <span style="color:#a6e22e">exited</span>: <span style="color:#a6e22e">status</span> <span style="color:#ae81ff">2.</span></code></pre></div>
<h3 id="range-and-close">Range and Close</h3>

<p>A sender can <code>close</code> a channel to indicate that no more values will be sent. Receivers can test whether a channel has been closed by assigning a second parameter to the receive expression: after</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch</span></code></pre></div>
<p><code>ok</code> is <code>false</code> if there are no more values to receive and the channel is closed.</p>

<p>The loop <code>for i := range c</code> receives values from the channel repeatedly until it is closed.</p>

<p>Note: Only the sender should close a channel, never the receiver. Sending on a closed channel will cause a panic.</p>

<p>Another note: Channels aren&rsquo;t like files; you don&rsquo;t usually need to close them. Closing is only necessary when the receiver must be told there are no more values coming, such as to terminate a <code>range</code> loop.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fibonacci</span>(<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">c</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">n</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">c</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">x</span>
		<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> = <span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">x</span><span style="color:#f92672">+</span><span style="color:#a6e22e">y</span>
	}
	close(<span style="color:#a6e22e">c</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">10</span>)
	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">fibonacci</span>(cap(<span style="color:#a6e22e">c</span>), <span style="color:#a6e22e">c</span>)
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">c</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">i</span>)
	}
}</code></pre></div>
<p>发送方可以 <code>close</code> 通道以表明数据已经发送完成。接收方可以通过将接受表达式赋给一个二值参数来测试通道是否已经被关闭：在</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch</span></code></pre></div>
<p>之后，如果没有数据可以接受，且通道已经关闭，则 <code>ok</code> 值为 <code>false</code>。</p>

<p>循环 <code>for i := range c</code> 重复从通道接收值直到其关闭。</p>

<p>注意：只有发送方应关闭通道，而不是接收方。在一个关闭的通道上发送数据将引发运行时恐慌。</p>

<p>另一个注意：通道与文件不一样；你通常不需要关闭它们。关闭操作仅仅在接收者必须被告知已经没有数据进来时才需要，比如终止 <code>range</code> 循环。</p>

<p>如果不   <code>close</code> 发送通达：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fibonacci</span>(<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">c</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">n</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">c</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">x</span>
		<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> = <span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">x</span><span style="color:#f92672">+</span><span style="color:#a6e22e">y</span>
	}
<span style="color:#75715e">//	close(c)
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">10</span>)
	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">fibonacci</span>(cap(<span style="color:#a6e22e">c</span>), <span style="color:#a6e22e">c</span>)
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span> = <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">c</span> {
		<span style="color:#75715e">//fmt.Println(i)
</span><span style="color:#75715e"></span>	}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;deadlock&#34;</span>)
}</code></pre></div>
<p>运行报错：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">fatal error: all goroutines are asleep - deadlock!

goroutine <span style="color:#ae81ff">1</span> <span style="color:#f92672">[</span>chan receive<span style="color:#f92672">]</span>:
main.main<span style="color:#f92672">()</span>
	/tmp/sandbox272038706/main.go:19 +0xa0

Program exited: status <span style="color:#ae81ff">2</span>.</code></pre></div>
<h3 id="select">Select</h3>

<p>The <code>select</code> statement lets a goroutine wait on multiple communication operations.</p>

<p>A <code>select</code> blocks until one of its cases can run, then it executes that case. It chooses one at random if multiple are ready.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fibonacci</span>(<span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">quit</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>
	<span style="color:#66d9ef">for</span> {
		<span style="color:#66d9ef">select</span> {
		<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">c</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">x</span>:
			<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> = <span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">x</span><span style="color:#f92672">+</span><span style="color:#a6e22e">y</span>
		<span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">quit</span>:
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;quit&#34;</span>)
			<span style="color:#66d9ef">return</span>
		}
	}
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
	<span style="color:#a6e22e">quit</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">c</span>)
		}
		<span style="color:#a6e22e">quit</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">0</span>
	}()
	<span style="color:#a6e22e">fibonacci</span>(<span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">quit</span>)
}</code></pre></div>
<p><code>select</code> 语句允许协程等待多个通信操作。</p>

<p><code>select</code> 阻塞，直到其中一个案例可以运行，然后执行该案例。如果多个案例都准备就绪，则随机选择一个。</p>

<h3 id="default-selection">Default Selection</h3>

<p>The <code>default</code> case in a <code>select</code> is run if no other case is ready.</p>

<p>Use a <code>default</code> case to try a send or receive without blocking:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">select</span> {
<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">c</span>:
    <span style="color:#75715e">// use i
</span><span style="color:#75715e"></span><span style="color:#66d9ef">default</span>:
    <span style="color:#75715e">// receiving from c would block
</span><span style="color:#75715e"></span>}</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;time&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">tick</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Tick</span>(<span style="color:#ae81ff">100</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Millisecond</span>)
	<span style="color:#a6e22e">boom</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">After</span>(<span style="color:#ae81ff">500</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Millisecond</span>)
	<span style="color:#66d9ef">for</span> {
		<span style="color:#66d9ef">select</span> {
		<span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">tick</span>:
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;tick.&#34;</span>)
		<span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">boom</span>:
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;BOOM!&#34;</span>)
			<span style="color:#66d9ef">return</span>
		<span style="color:#66d9ef">default</span>:
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;    .&#34;</span>)
			<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#ae81ff">50</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Millisecond</span>)
		}
	}
}</code></pre></div>
<p><code>select</code> 中的 <code>default</code> 案例在没有其它案例准备好时运行。</p>

<p>使用 <code>default</code> 案例来尝试发送或者接收而不阻塞：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">select</span> {
<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">c</span>:
    <span style="color:#75715e">// use i
</span><span style="color:#75715e"></span><span style="color:#66d9ef">default</span>:
    <span style="color:#75715e">// receiving from c would block
</span><span style="color:#75715e"></span>}</code></pre></div>
<h3 id="exercise-equivalent-binary-trees">Exercise: Equivalent Binary Trees</h3>

<p>Exercise: Equivalent Binary Trees
There can be many different binary trees with the same sequence of values stored at the leaves. For example, here are two binary trees storing the sequence 1, 1, 2, 3, 5, 8, 13.</p>

<p><center><img src="http://idevz.github.io/images/tree.png" alt="d" /></center></p>

<p>A function to check whether two binary trees store the same sequence is quite complex in most languages. We&rsquo;ll use Go&rsquo;s concurrency and channels to write a simple solution.</p>

<p>This example uses the <code>tree</code> package, which defines the type:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Tree</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#a6e22e">Left</span>  <span style="color:#f92672">*</span><span style="color:#a6e22e">Tree</span>
    <span style="color:#a6e22e">Value</span> <span style="color:#66d9ef">int</span>
    <span style="color:#a6e22e">Right</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Tree</span>
}</code></pre></div>
<p>Continue description on <a href="https://tour.golang.org/concurrency/8">next page</a>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"></code></pre></div>
<h3 id="exercise-equivalent-binary-trees-1">Exercise: Equivalent Binary Trees</h3>

<ol>
<li><p>Implement the <code>Walk</code> function.</p></li>

<li><p>Test the <code>Walk</code> function.</p></li>
</ol>

<p>The function <code>tree.New(k)</code> constructs a randomly-structured (but always sorted) binary tree holding the values <code>k</code>, <code>2k</code>, <code>3k</code>, &hellip;, <code>10k</code>.</p>

<p>Create a new channel ch and kick off the walker:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">go</span> <span style="color:#a6e22e">Walk</span>(<span style="color:#a6e22e">tree</span>.<span style="color:#a6e22e">New</span>(<span style="color:#ae81ff">1</span>), <span style="color:#a6e22e">ch</span>)</code></pre></div>
<p>Then read and print 10 values from the channel. It should be the numbers 1, 2, 3, &hellip;, 10.</p>

<ol>
<li><p>Implement the <code>Same</code> function using <code>Walk</code> to determine whether <code>t1</code> and <code>t2</code> store the same values.</p></li>

<li><p>Test the <code>Same</code> function.</p></li>
</ol>

<p><code>Same(tree.New(1), tree.New(1))</code> should return true, and <code>Same(tree.New(1), tree.New(2))</code> should return false.</p>

<p>The documentation for <code>Tree</code> can be found <a href="https://godoc.org/golang.org/x/tour/tree#Tree">here</a>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;golang.org/x/tour/tree&#34;</span>

<span style="color:#75715e">// Walk walks the tree t sending all values
</span><span style="color:#75715e">// from the tree to the channel ch.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Walk</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">tree</span>.<span style="color:#a6e22e">Tree</span>, <span style="color:#a6e22e">ch</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)

<span style="color:#75715e">// Same determines whether the trees
</span><span style="color:#75715e">// t1 and t2 contain the same values.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Same</span>(<span style="color:#a6e22e">t1</span>, <span style="color:#a6e22e">t2</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">tree</span>.<span style="color:#a6e22e">Tree</span>) <span style="color:#66d9ef">bool</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
}</code></pre></div>
<ol>
<li><p>Implement the <code>Walk</code> function.</p></li>

<li><p>Test the <code>Walk</code> function.</p></li>
</ol>

<p>The function <code>tree.New(k)</code> constructs a randomly-structured (but always sorted) binary tree holding the values <code>k</code>, <code>2k</code>, <code>3k</code>, &hellip;, <code>10k</code>.</p>

<p>Create a new channel ch and kick off the walker:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">go</span> <span style="color:#a6e22e">Walk</span>(<span style="color:#a6e22e">tree</span>.<span style="color:#a6e22e">New</span>(<span style="color:#ae81ff">1</span>), <span style="color:#a6e22e">ch</span>)</code></pre></div>
<p>Then read and print 10 values from the channel. It should be the numbers 1, 2, 3, &hellip;, 10.</p>

<ol>
<li><p>Implement the <code>Same</code> function using <code>Walk</code> to determine whether <code>t1</code> and <code>t2</code> store the same values.</p></li>

<li><p>Test the <code>Same</code> function.</p></li>
</ol>

<p><code>Same(tree.New(1), tree.New(1))</code> should return true, and <code>Same(tree.New(1), tree.New(2))</code> should return false.</p>

<p>The documentation for <code>Tree</code> can be found <a href="https://godoc.org/golang.org/x/tour/tree#Tree">here</a>.</p>

<h3 id="sync-mutex">sync.Mutex</h3>

<p>We&rsquo;ve seen how channels are great for communication among goroutines.</p>

<p>But what if we don&rsquo;t need communication? What if we just want to make sure only one goroutine can access a variable at a time to avoid conflicts?</p>

<p>This concept is called mutual exclusion, and the conventional name for the data structure that provides it is mutex.</p>

<p>Go&rsquo;s standard library provides mutual exclusion with <code>sync.Mutex</code> and its two methods:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">Lock</span>
<span style="color:#a6e22e">Unlock</span></code></pre></div>
<p>We can define a block of code to be executed in mutual exclusion by surrounding it with a call to <code>Lock</code> and <code>Unlock</code> as shown on the <code>Inc</code> method.</p>

<p>We can also use <code>defer</code> to ensure the mutex will be unlocked as in the <code>Value</code> method.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;sync&#34;</span>
	<span style="color:#e6db74">&#34;time&#34;</span>
)

<span style="color:#75715e">// SafeCounter is safe to use concurrently.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">SafeCounter</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">v</span>   <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">int</span>
	<span style="color:#a6e22e">mux</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Mutex</span>
}

<span style="color:#75715e">// Inc increments the counter for the given key.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">SafeCounter</span>) <span style="color:#a6e22e">Inc</span>(<span style="color:#a6e22e">key</span> <span style="color:#66d9ef">string</span>) {
	<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">mux</span>.<span style="color:#a6e22e">Lock</span>()
	<span style="color:#75715e">// Lock so only one goroutine at a time can access the map c.v.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">v</span>[<span style="color:#a6e22e">key</span>]<span style="color:#f92672">++</span>
	<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">mux</span>.<span style="color:#a6e22e">Unlock</span>()
}

<span style="color:#75715e">// Value returns the current value of the counter for the given key.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">SafeCounter</span>) <span style="color:#a6e22e">Value</span>(<span style="color:#a6e22e">key</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">int</span> {
	<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">mux</span>.<span style="color:#a6e22e">Lock</span>()
	<span style="color:#75715e">// Lock so only one goroutine at a time can access the map c.v.
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">mux</span>.<span style="color:#a6e22e">Unlock</span>()
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">v</span>[<span style="color:#a6e22e">key</span>]
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">SafeCounter</span>{<span style="color:#a6e22e">v</span>: make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">int</span>)}
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">1000</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">Inc</span>(<span style="color:#e6db74">&#34;somekey&#34;</span>)
	}

	<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">Value</span>(<span style="color:#e6db74">&#34;somekey&#34;</span>))
}</code></pre></div>
<p>我们已经看到了通道如何在协程间进行通信。</p>

<p>但是，如果我们不需要通信呢？如果我们仅仅想保证同时只有一个协程可以访问一个变量避免发生冲突，那该怎么办？</p>

<p>这种概念被称为互斥，提供它的数据结构常规名称是 mutex（互斥）。</p>

<p>Go 语言标准库通过 <code>sync.Mutex</code> 和它的两个方法 提供了互斥的机制：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">Lock</span>
<span style="color:#a6e22e">Unlock</span></code></pre></div>
<p>我们可以通过调用 <code>Lock</code> 和 <code>Unlock</code> 来定义要在互斥中执行的代码块，如 <code>Inc</code> 方法所示。</p>

<p>我们同样可以使用 <code>defer</code> 来确保互斥锁像 <code>Value</code> 方法那样被解除。</p>

<h3 id="exercise-web-crawler">Exercise: Web Crawler</h3>

<p>In this exercise you&rsquo;ll use Go&rsquo;s concurrency features to parallelize a web crawler.</p>

<p>Modify the <code>Crawl</code> function to fetch URLs in parallel without fetching the same URL twice.</p>

<p>Hint: you can keep a cache of the URLs that have been fetched on a map, but maps alone are not safe for concurrent use!</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
)

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Fetcher</span> <span style="color:#66d9ef">interface</span> {
	<span style="color:#75715e">// Fetch returns the body of URL and
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// a slice of URLs found on that page.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">Fetch</span>(<span style="color:#a6e22e">url</span> <span style="color:#66d9ef">string</span>) (<span style="color:#a6e22e">body</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">urls</span> []<span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>)
}

<span style="color:#75715e">// Crawl uses fetcher to recursively crawl
</span><span style="color:#75715e">// pages starting with url, to a maximum of depth.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Crawl</span>(<span style="color:#a6e22e">url</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">depth</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">fetcher</span> <span style="color:#a6e22e">Fetcher</span>) {
	<span style="color:#75715e">// TODO: Fetch URLs in parallel.
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// TODO: Don&#39;t fetch the same URL twice.
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// This implementation doesn&#39;t do either:
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">depth</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span> {
		<span style="color:#66d9ef">return</span>
	}
	<span style="color:#a6e22e">body</span>, <span style="color:#a6e22e">urls</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">fetcher</span>.<span style="color:#a6e22e">Fetch</span>(<span style="color:#a6e22e">url</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">err</span>)
		<span style="color:#66d9ef">return</span>
	}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;found: %s %q\n&#34;</span>, <span style="color:#a6e22e">url</span>, <span style="color:#a6e22e">body</span>)
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">u</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">urls</span> {
		<span style="color:#a6e22e">Crawl</span>(<span style="color:#a6e22e">u</span>, <span style="color:#a6e22e">depth</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">fetcher</span>)
	}
	<span style="color:#66d9ef">return</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">Crawl</span>(<span style="color:#e6db74">&#34;https://golang.org/&#34;</span>, <span style="color:#ae81ff">4</span>, <span style="color:#a6e22e">fetcher</span>)
}

<span style="color:#75715e">// fakeFetcher is Fetcher that returns canned results.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">fakeFetcher</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#f92672">*</span><span style="color:#a6e22e">fakeResult</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">fakeResult</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">body</span> <span style="color:#66d9ef">string</span>
	<span style="color:#a6e22e">urls</span> []<span style="color:#66d9ef">string</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">f</span> <span style="color:#a6e22e">fakeFetcher</span>) <span style="color:#a6e22e">Fetch</span>(<span style="color:#a6e22e">url</span> <span style="color:#66d9ef">string</span>) (<span style="color:#66d9ef">string</span>, []<span style="color:#66d9ef">string</span>, <span style="color:#66d9ef">error</span>) {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">res</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">f</span>[<span style="color:#a6e22e">url</span>]; <span style="color:#a6e22e">ok</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">res</span>.<span style="color:#a6e22e">body</span>, <span style="color:#a6e22e">res</span>.<span style="color:#a6e22e">urls</span>, <span style="color:#66d9ef">nil</span>
	}
	<span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&#34;</span>, <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;not found: %s&#34;</span>, <span style="color:#a6e22e">url</span>)
}

<span style="color:#75715e">// fetcher is a populated fakeFetcher.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">fetcher</span> = <span style="color:#a6e22e">fakeFetcher</span>{
	<span style="color:#e6db74">&#34;https://golang.org/&#34;</span>: <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">fakeResult</span>{
		<span style="color:#e6db74">&#34;The Go Programming Language&#34;</span>,
		[]<span style="color:#66d9ef">string</span>{
			<span style="color:#e6db74">&#34;https://golang.org/pkg/&#34;</span>,
			<span style="color:#e6db74">&#34;https://golang.org/cmd/&#34;</span>,
		},
	},
	<span style="color:#e6db74">&#34;https://golang.org/pkg/&#34;</span>: <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">fakeResult</span>{
		<span style="color:#e6db74">&#34;Packages&#34;</span>,
		[]<span style="color:#66d9ef">string</span>{
			<span style="color:#e6db74">&#34;https://golang.org/&#34;</span>,
			<span style="color:#e6db74">&#34;https://golang.org/cmd/&#34;</span>,
			<span style="color:#e6db74">&#34;https://golang.org/pkg/fmt/&#34;</span>,
			<span style="color:#e6db74">&#34;https://golang.org/pkg/os/&#34;</span>,
		},
	},
	<span style="color:#e6db74">&#34;https://golang.org/pkg/fmt/&#34;</span>: <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">fakeResult</span>{
		<span style="color:#e6db74">&#34;Package fmt&#34;</span>,
		[]<span style="color:#66d9ef">string</span>{
			<span style="color:#e6db74">&#34;https://golang.org/&#34;</span>,
			<span style="color:#e6db74">&#34;https://golang.org/pkg/&#34;</span>,
		},
	},
	<span style="color:#e6db74">&#34;https://golang.org/pkg/os/&#34;</span>: <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">fakeResult</span>{
		<span style="color:#e6db74">&#34;Package os&#34;</span>,
		[]<span style="color:#66d9ef">string</span>{
			<span style="color:#e6db74">&#34;https://golang.org/&#34;</span>,
			<span style="color:#e6db74">&#34;https://golang.org/pkg/&#34;</span>,
		},
	},
}</code></pre></div>
<p>在本次练习中你将使用 Go 语言的并发特性来并行化一个网络爬虫程序。</p>

<p>修改 <code>Crawl</code> 函数来并行的抓取网页链接，而无需两次获取相同的网页链接。</p>

<p>提示：你可以保留已在映射上提取网页链接的缓存，但单独的映射本身并不是并发安全的！</p>

<h3 id="where-to-go-from-here">Where to Go from here …</h3>

<p>You can get started by <a href="https://golang.org/dl/">installing Go</a>.</p>

<p>Once you have Go installed, the <a href="https://golang.org/doc/">Go Documentation</a> is a great place to continue. It contains references, tutorials, videos, and more.</p>

<p>To learn how to organize and work with Go code, watch <a href="https://www.youtube.com/watch?v=XCsL89YtqCs">this screencast</a> or read <a href="https://golang.org/doc/code.html">How to Write Go Code</a>.</p>

<p>If you need help with the standard library, see the <a href="https://golang.org/pkg/">package reference</a>. For help with the language itself, you might be surprised to find the <a href="https://golang.org/ref/spec">Language Spec</a> is quite readable.</p>

<p>To further explore Go&rsquo;s concurrency model, watch <a href="https://www.youtube.com/watch?v=f6kdp27TYZs">Go Concurrency Patterns</a> (<a href="https://talks.golang.org/2012/concurrency.slide">slides</a>) and <a href="https://www.youtube.com/watch?v=QDDwwePbDtw">Advanced Go Concurrency Patterns</a> (<a href="https://talks.golang.org/2013/advconc.slide">slides</a>) and read the <a href="https://golang.org/doc/codewalk/sharemem/">Share Memory by Communicating</a> codewalk.</p>

<p>To get started writing web applications, watch <a href="https://vimeo.com/53221558">A simple programming environment</a> (<a href="https://talks.golang.org/2012/simple.slide">slides</a>) and read the <a href="https://golang.org/doc/articles/wiki/">Writing Web Applications</a> tutorial.</p>

<p>The <a href="https://golang.org/doc/codewalk/functions/">First Class Functions in Go</a> codewalk gives an interesting perspective on Go&rsquo;s function types.</p>

<p>The <a href="https://blog.golang.org/">Go Blog</a> has a large archive of informative Go articles.</p>

<p>Visit <a href="https://golang.org/">golang.org</a> for more.</p>

<p>你可以从<a href="https://golang.org/dl/">安装 Go</a>开始。</p>

<p>一旦安装了 Go，<a href="https://golang.org/doc/">Go 文档</a> 就是一个继续学习的好地方。它包含了参考、教程、视频等等。</p>

<p>观看<a href="https://www.youtube.com/watch?v=XCsL89YtqCs">这个屏幕视频</a> 或者阅读 <a href="https://golang.org/doc/code.html">How to Write Go Code</a> 来学习如何组织和编写 Go 代码。</p>

<p>如果你需要标准库相关的帮助，查看<a href="https://golang.org/pkg/">包帮助文档</a>。有关语言本身的帮助，你可能会惊讶地发现<a href="https://golang.org/ref/spec">语言规范</a> 非常易读。</p>

<p>想进一步探索 Go 语言的并发模型，查看 youtube 视频 <a href="https://www.youtube.com/watch?v=f6kdp27TYZs">Go Concurrency Patterns</a> (<a href="https://talks.golang.org/2012/concurrency.slide">相关幻灯片</a>) 和 <a href="https://www.youtube.com/watch?v=QDDwwePbDtw">Advanced Go Concurrency Patterns</a> (<a href="https://talks.golang.org/2013/advconc.slide">相关幻灯片</a>) 并通过阅读文章  <a href="https://golang.org/doc/codewalk/sharemem/">Share Memory by Communicating</a> 代码指南。</p>

<p>开始编写网页应用，参看 <a href="https://vimeo.com/53221558">A simple programming environment</a> (<a href="https://talks.golang.org/2012/simple.slide">相关幻灯片</a>) 和阅读 <a href="https://golang.org/doc/articles/wiki/">Writing Web Applications</a> 教程。</p>

<p><a href="https://golang.org/doc/codewalk/functions/">First Class Functions in Go</a> 编码指南给出了从 Go 语言函数类型有趣的视角。</p>

<p><a href="https://blog.golang.org/">Go Blog</a> 有大量关于 Go 语言的教育性文章的归档。</p>

<p>访问 <a href="https://golang.org/">golang.org</a> 了解更多信息。</p>

</div>

  
<footer class='entry-footer'>
  <div class='container sep-before'><div class='categories'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <path d="M22,19a2,2,0,0,1-2,2H4a2,2,0,0,1-2-2V5A2,2,0,0,1,4,3H9l2,3h9a2,2,0,0,1,2,2Z"/>
  
</svg>
<span class='screen-reader-text'>Categories: </span><a class='category' href='http://idevz.github.io/categories/%E6%8A%80%E6%9C%AF/'>技术</a>, </div>
<div class='tags'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <path d="M20.59,13.41l-7.17,7.17a2,2,0,0,1-2.83,0L2,12V2H12l8.59,8.59A2,2,0,0,1,20.59,13.41Z"/>
  <line x1="7" y1="7" x2="7" y2="7"/>
  
</svg>
<span class='screen-reader-text'>Tags: </span><a class='tag' href='http://idevz.github.io/tags/golang/'>Golang</a></div>

  </div>
</footer>


</article>

<nav class='entry-nav'>
  <div class='container'><div class='prev-entry sep-before'>
      <a href='http://idevz.github.io/2018/11/service-mesh-%E4%B8%80%E7%A7%8D%E6%96%B0%E7%9A%84%E6%A8%A1%E5%BC%8F%E8%80%8C%E4%B8%8D%E6%98%AF%E6%96%B0%E6%8A%80%E6%9C%AF/'>
        <span aria-hidden='true'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <line x1="20" y1="12" x2="4" y2="12"/>
  <polyline points="10 18 4 12 10 6"/>
  
</svg>
 Previous</span>
        <span class='screen-reader-text'>Previous post: </span>Service mesh — 一种新的模式而不是新技术</a>
    </div></div>
</nav>




      </main>

      <footer id='footer' class='footer'>
        <div class='container sep-before'><div class='copyright'>
  <p>© 2020 idevz.org</p>
</div>

        </div>
      </footer>

    </div>
  </div><script>window.__assets_js_src="http://idevz.github.io/assets/js/"</script>

<script src='http://idevz.github.io/assets/js/main.67d669ac.js'></script>

</body>

</html>

