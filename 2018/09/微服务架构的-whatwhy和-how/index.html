<!DOCTYPE html>
<html lang='en'><head>
  <meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='description' content='原著信息： The What, Why, and How of a Microservices Architecture
by:Jetinder Singh
For many years now we have been building systems and getting better at it. Several technologies, architectural patterns, and best practices have emerged over those years. Microservices is one of those architectural patterns which has emerged from the world of domain-driven design, continuous delivery, platform and infrastructure automation, scalable systems, polyglot programming and persistence.
多年来我们构建系统并且做到越来越好。这些年出现了一些技术、架构模式和最佳实践。微服务是从领域驱动设计，持续交付，平台和基础设施自动化，可扩展系统，多语言编程和持久性领域的架构模式之一。
What is a Microservices Architecture in a Nutshell?'>
<meta name='theme-color' content='#ffcd00'>

<meta property='og:title' content='微服务架构的 What，Why，和 How • 做一个善于思考的学习者'>
<meta property='og:description' content='原著信息： The What, Why, and How of a Microservices Architecture
by:Jetinder Singh
For many years now we have been building systems and getting better at it. Several technologies, architectural patterns, and best practices have emerged over those years. Microservices is one of those architectural patterns which has emerged from the world of domain-driven design, continuous delivery, platform and infrastructure automation, scalable systems, polyglot programming and persistence.
多年来我们构建系统并且做到越来越好。这些年出现了一些技术、架构模式和最佳实践。微服务是从领域驱动设计，持续交付，平台和基础设施自动化，可扩展系统，多语言编程和持久性领域的架构模式之一。
What is a Microservices Architecture in a Nutshell?'>
<meta property='og:url' content='https://idevz.github.io/2018/09/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9A%84-whatwhy%E5%92%8C-how/'>
<meta property='og:site_name' content='做一个善于思考的学习者'>
<meta property='og:type' content='article'><meta property='article:section' content='tech'><meta property='article:tag' content='微服务'><meta property='article:tag' content='Architecture'><meta property='article:published_time' content='2018-09-18T22:11:56&#43;08:00'/><meta property='article:modified_time' content='2019-04-08T22:05:43&#43;08:00'/><meta name='twitter:card' content='summary'>

<meta name="generator" content="Hugo 0.60.0-DEV" />

  <title>微服务架构的 What，Why，和 How • 做一个善于思考的学习者</title>
  <link rel='canonical' href='https://idevz.github.io/2018/09/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9A%84-whatwhy%E5%92%8C-how/'>
  
  
  <link rel='icon' href='https://idevz.github.io/favicon.ico'>
<link rel='stylesheet' href='https://idevz.github.io/assets/css/main.6a060eb7.css'><style>
:root{--color-accent:#ffcd00;}
</style>

<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-71947507-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  

</head><body class='page type-tech'>

  <div class='site'><a class='screen-reader-text' href='#content'>Skip to Content</a><div class='main'><nav id='main-menu' class='menu main-menu' aria-label='Main Menu'>
  <div class='container'>
    
    <ul><li class='item'>
        <a href='https://idevz.github.io/'>idevz.org</a>
      </li><li class='item'>
        <a href='https://idevz.github.io/tech/'>技术</a>
      </li><li class='item'>
        <a href='https://idevz.github.io/tools/'>工具</a>
      </li><li class='item'>
        <a href='https://idevz.github.io/life/'>Life</a>
      </li><li class='item'>
        <a href='https://idevz.github.io/page/about/'>关于</a>
      </li></ul>
  </div>
</nav><div class='header-widgets'>
        <div class='container'></div>
      </div>

      <header id='header' class='header site-header'>
        <div class='container sep-after'>
          <div class='header-info'><p class='site-title title'>做一个善于思考的学习者</p><p class='desc site-desc'>Every Day Create Your History.</p>
          </div>
        </div>
      </header>

      <main id='content'>


<article lang='en' class='entry'>
  <header class='header entry-header'>
  <div class='container sep-after'>
    <div class='header-info'>
      <h1 class='title'>微服务架构的 What，Why，和 How</h1>
      

    </div>
    <div class='entry-meta'>
  <span class='posted-on'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"/>
  <line x1="16" y1="2" x2="16" y2="6"/>
  <line x1="8" y1="2" x2="8" y2="6"/>
  <line x1="3" y1="10" x2="21" y2="10"/>
  
</svg>
<span class='screen-reader-text'>Posted on </span>
  <time class='entry-date' datetime='2018-09-18T22:11:56&#43;08:00'>2018, Sep 18</time>
</span>

  
  
<span class='reading-time'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <circle cx="12" cy="12" r="10"/>
  <polyline points="12 6 12 12 15 15"/>
  
</svg>
15 mins read
</span>


</div>


  </div>
</header>

  
  
<details class='container entry-toc'>
  <summary class='title'>
    <span>Table of Contents</span>
  </summary>
  <nav id="TableOfContents">
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#what-is-a-microservices-architecture-in-a-nutshell"><strong>What is a Microservices Architecture in a Nutshell?</strong></a></li>
<li><a href="#简而言之什么是微服务架构"><strong>简而言之什么是微服务架构？</strong></a></li>
<li><a href="#key-benefits-of-a-microservices-architecture"><strong>Key Benefits of a Microservices Architecture</strong></a></li>
<li><a href="#微服务架构的核心收益"><strong>微服务架构的核心收益</strong></a></li>
<li><a href="#how-do-i-get-started-with-a-microservices-architecture"><strong>How Do I Get Started with a Microservices Architecture?</strong></a></li>
<li><a href="#如何开始使用微服务架构"><strong>如何开始使用微服务架构？</strong></a></li>
<li><a href="#1-how-to-decompose"><strong>1.</strong> <strong>How to Decompose</strong></a></li>
<li><a href="#1-如何分解"><strong>1.</strong> <strong>如何分解</strong></a></li>
<li><a href="#2-building-and-deploying"><strong>2. Building and Deploying</strong></a></li>
<li><a href="#2-构建和部署"><strong>2. 构建和部署</strong></a></li>
<li><a href="#3-design-the-individual-services-carefully"><strong>3. Design the Individual Services Carefully</strong></a></li>
<li><a href="#3-仔细设计各个服务"><strong>3. 仔细设计各个服务</strong></a></li>
<li><a href="#4-decentralize-things"><strong>4. Decentralize Things</strong></a></li>
<li><a href="#4-分散事物"><strong>4. 分散事物</strong></a></li>
<li><a href="#5-deploy"><strong>5. Deploy</strong></a></li>
<li><a href="#multiple-microservices-per-operating-system"><strong>Multiple Microservices Per Operating System</strong></a></li>
<li><a href="#one-microservice-per-operating-system"><strong>One Microservice Per Operating System</strong></a></li>
<li><a href="#making-changes-to-existing-microservice-apis-while-in-production"><strong>Making Changes to Existing Microservice APIs While In Production</strong></a></li>
<li><a href="#5-部署"><strong>5. 部署</strong></a></li>
<li><a href="#每个操作系统的多个微服务"><strong>每个操作系统的多个微服务</strong></a></li>
<li><a href="#每个操作系统一个微服务"><strong>每个操作系统一个微服务</strong></a></li>
<li><a href="#在生产中对现有微服务api进行更改"><strong>在生产中对现有微服务API进行更改</strong></a></li>
<li><a href="#6-making-standards"><strong>6. Making Standards</strong></a></li>
<li><a href="#service-dependencies"><strong>Service Dependencies</strong></a></li>
<li><a href="#6-制作标准"><strong>6. 制作标准</strong></a></li>
<li><a href="#服务依赖"><strong>服务依赖</strong></a></li>
<li><a href="#7-failure"><strong>7. Failure</strong></a></li>
<li><a href="#bulkhead"><strong>Bulkhead</strong></a></li>
<li><a href="#circuit-breaker"><strong>Circuit Breaker</strong></a></li>
<li><a href="#7-失败"><strong>7. 失败</strong></a></li>
<li><a href="#隔离"><strong>隔离</strong></a></li>
<li><a href="#断路器"><strong>断路器</strong></a></li>
<li><a href="#8-monitoring-and-logging"><strong>8. Monitoring and Logging</strong></a></li>
<li><a href="#log-aggregation"><strong>Log Aggregation</strong></a></li>
<li><a href="#stats-aggregation"><strong>Stats Aggregation</strong></a></li>
<li><a href="#8-监控和日志"><strong>8. 监控和日志</strong></a></li>
<li><a href="#日志聚合"><strong>日志聚合</strong></a></li>
<li><a href="#统计聚合"><strong>统计聚合</strong></a></li>
<li><a href="#one-last-thing"><strong>One Last Thing</strong></a></li>
<li><a href="#最后一点"><strong>最后一点</strong></a></li>
</ul></li>
</ul></li>
</ul>
</nav>
</details>


  <div class='container entry-content'>
  

<p><strong>原著信息：</strong>
<a href="https://medium.com/hashmapinc/the-what-why-and-how-of-a-microservices-architecture-4179579423a9">The What, Why, and How of a Microservices Architecture</a></p>

<p><strong>by:Jetinder Singh</strong></p>

<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g0wm2l04jzj318g0tm40p.jpg" alt="" /></p>

<p>For many years now we have been building systems and getting better at it. Several technologies, architectural patterns, and best practices have emerged over those years. Microservices is one of those architectural patterns which has emerged from the world of domain-driven design, continuous delivery, platform and infrastructure automation, scalable systems, polyglot programming and persistence.</p>

<p>多年来我们构建系统并且做到越来越好。这些年出现了一些技术、架构模式和最佳实践。微服务是从领域驱动设计，持续交付，平台和基础设施自动化，可扩展系统，多语言编程和持久性领域的架构模式之一。</p>

<h3 id="what-is-a-microservices-architecture-in-a-nutshell"><strong>What is a Microservices Architecture in a Nutshell?</strong></h3>

<p>Robert C. Martin coined the term <a href="https://en.wikipedia.org/wiki/Single_responsibility_principle">single responsibility principle</a> which states “gather together those things that change for the same reason, and separate those things that change for different reasons.”</p>

<p>A microservices architecture takes this same approach and extends it to the loosely coupled services which can be developed, deployed, and maintained independently. Each of these services is responsible for discrete task and can communicate with other services through simple APIs to solve a larger complex business problem.</p>

<h3 id="简而言之什么是微服务架构"><strong>简而言之什么是微服务架构？</strong></h3>

<p>Robert C.Martin 创造了“单一职责原则”这个词语，其中指出“把那些因为同样的原因而改变的事物聚集在一起，并将因不同原因而改变的事物分开。”</p>

<p>微服务架构采用了相同的方法，并且将其扩展为可以独立开发、部署、维护的松散耦合服务。这些服务中每一个都负责离散任务且可以通过简单的 API 与其它服务通信，以解决大而复杂的业务问题。</p>

<h3 id="key-benefits-of-a-microservices-architecture"><strong>Key Benefits of a Microservices Architecture</strong></h3>

<p>As the constituent services are small, they can be built by one or more small teams from the beginning separated by service boundaries which make it easier to scale up the development effort if need be.</p>

<p>Once developed, these services can also be deployed independently of each other and hence its easy to identify hot services and scale them independent of whole application. Microservices also offer improved fault isolation whereby in the case of an error in one service the whole application doesn’t necessarily stop functioning. When the error is fixed, it can be deployed only for the respective service instead of redeploying an entire application.</p>

<p>Another advantage which a microservices architecture brings to the table is making it easier to choose the technology stack (programming languages, databases, etc.) which is best suited for the required functionality (service) instead of being required to take a more standardized, one-size-fits-all approach.</p>

<h3 id="微服务架构的核心收益"><strong>微服务架构的核心收益</strong></h3>

<p>由于组成的服务很小，一开始它们可以由一个或者更小按照服务边界来分隔的团队维护。这样可以在需要扩充开发工作时更容易。</p>

<p>这些服务一旦被开发出来，它们可以相互独立部署，因此很容易识别热服务并且可以在整个应用中单独为其扩容。微服务还提供了改进的故障隔离，从而在一个服务出错时，整个应用不需要停止服务。当错误被解决，也仅需部署相应的服务而不是重新部署整个应用。</p>

<p>微服务架构带来的另一个优势是使得选择哪个最适合所需功能（服务）的技术栈（编程语言、数据库等）变得更简单，而不是需要选择更标准的放之四海而皆准的方案。</p>

<h3 id="how-do-i-get-started-with-a-microservices-architecture"><strong>How Do I Get Started with a Microservices Architecture?</strong></h3>

<p>Hopefully, you’re now convinced that a microservices architecture can offer some unique advantages over traditional architectures and you’ve started thinking about this type of approach for your next project.</p>

<p>The very next question that comes to mind is “How do I start?” — and — “Is there a standard set of principles which I can follow to help me build a microservices architecture in a better way?”</p>

<p>Well, I’m afraid the answer is “No”.</p>

<p>While that might not sound that promising, there are, however, some common themes which many organizations that have adopted microservices architectures have followed and with which they have ultimately found success. I’ll discuss some of those common themes below.</p>

<h3 id="如何开始使用微服务架构"><strong>如何开始使用微服务架构？</strong></h3>

<p>希望你现在已经确信，微服务架构相比传统架构能提供一些独特的优势，并且你开始为你的下一个项目思考此类似的方案。</p>

<p>我想到的下一个问题是“如何开始？” 以及“是否有一套我可以遵循的标准原则来帮助我更好的构建微服务架构？”</p>

<p>然而，我恐怕答案是“不”。</p>

<p>尽管这听起来不那么有希望，然而一些共同的主题很多已经采用微服务架构的组织都已经遵循且最终都取得成功。下面我将讨论一些这样的主题。</p>

<h3 id="1-how-to-decompose"><strong>1.</strong> <strong>How to Decompose</strong></h3>

<p>One of the ways to make our job easier could be to define services corresponding to business capabilities. A business capability is something a business does in order to provide value to its end users.</p>

<p>Identifying business capabilities and corresponding services requires a high level understanding of the business. For example, the business capabilities for an online shopping application might include the following..</p>

<p>● Product Catalog Management</p>

<p>● Inventory Management</p>

<p>● Order Management</p>

<p>● Delivery Management</p>

<p>● User Management</p>

<p>● Product Recommendations</p>

<p>● Product Reviews Management</p>

<p>Once the business capabilities have been identified, the required services can be built corresponding to each of these identified business capabilities.</p>

<p>Each service can be owned by a different team who becomes an expert in that particular domain and an expert in the technologies that are best suited for those particular services. This often leads to more stable API boundaries and more stable teams.</p>

<h3 id="1-如何分解"><strong>1.</strong> <strong>如何分解</strong></h3>

<p>让我们工作更轻松的方法之一是根据业务功能来定义服务。业务功能是企业为其最终用户提供价值的东西。</p>

<p>识别业务功能和其对应的服务需要对业务的高层次理解。例如，一个在线商城应用的业务功能可能包括以下内容：</p>

<ul>
<li>产品目录管理</li>
<li>库存管理</li>
<li>订单管理</li>
<li>交货管理</li>
<li>用户管理</li>
<li>产品推荐</li>
<li>产品评论管理</li>
</ul>

<p>一旦确定了业务功能，就可以根据每个已定义的业务功能来构建所需的服务。</p>

<p>每个服务都可以被不同的在特定领域成为专家的不同团队和最适合这些特定服务的技术的专家所拥有。这通常会带来更稳定的 API 边界和更稳定的团队。</p>

<h3 id="2-building-and-deploying"><strong>2. Building and Deploying</strong></h3>

<p>After deciding on the service boundaries of these small services, they can be developed by one or more small teams using the technologies which are best suited for each purpose. For example, you may choose to build a User Service in Java with a MySQL database and a Product Recommendation Service with Scala/Spark.</p>

<p>Once developed, CI/CD pipelines can be setup with any of the available CI servers (Jenkins, TeamCity, Go, etc.) to run the automated test cases and and deploy these service independently to different environments (Integration, QA, Staging, Production, etc).</p>

<h3 id="2-构建和部署"><strong>2. 构建和部署</strong></h3>

<p>在决定了这些小型服务的服务边界后，它们可以被一个或者更小的团队使用最适合每个功能的技术来开发。例如，你可以选择使用 Java 和 MySQL 数据库来构建用户服务，用 Scala / Spark 来构建产品推荐服务。</p>

<p>开发完成后，可以使用任何可用的 CI 服务（Jenkins、TeamCity，Go等）设置 CI/CD 流水线来运行自动化测试用例以及将这些服务独立的部署到不同的环境（集成、QA、分段、生产等）。</p>

<h3 id="3-design-the-individual-services-carefully"><strong>3. Design the Individual Services Carefully</strong></h3>

<p>When designing the services, carefully define them and think about what will be exposed, what protocols will be used to interact with the service, etc.</p>

<p>It is very important to hide any complexity and implementation details of the service and only expose what is needed by the service’s clients. If unnecessary details are exposed, it becomes very difficult to change the service later as there will be alot of painstaking work to determine who is relying on the various parts of the service. Additionally, a great deal of flexibility is lost in being able to deploying the service independently.</p>

<p>The diagram below shows one of the common mistakes in designing microservices:</p>

<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g0wpc2kabej30dy08qdg0.jpg" alt="" /></p>

<p>As you can see in the diagram, here we are taking a service (Service 1) and storing all of the information needed by the service to a database. When another service (Service 2) is created which needs that same data, we access that data directly from the database.</p>

<p>This approach might seem reasonable and logical in certain instances — maybe it’s easy to access data in a SQL database or write data to a SQL database or maybe the APIs needed by Service 2 are not readily available.</p>

<p>As soon as this approach is adopted, control is immediately lost in determining what is hidden and what is not. Later on, if the schema needs to change, the flexibility to make that change is lost, since you won’t know who is using the database and whether the change will break Service 2 or not.</p>

<p>An alternative approach, and I would submit the right way to tackle this, is below:</p>

<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g0wqgxzdahj30dy08qwek.jpg" alt="img" /></p>

<p>Service 2 should access Service 1 and avoid going directly to the database, therefore preserving utmost flexibility for various schema changes that may be required. Worrying about other parts of the system is eliminated provided you make sure that tests for exposed APIs pass.</p>

<p>As mentioned, choose the protocols for communication between services carefully. For example, if Java RMI is chosen, not only is the user of the API restricted to using a JVM based language, but in addition, the protocol in and of itself is quite brittle because it’s difficult to maintain backward compatibility with the API.</p>

<p>Lastly, when providing client libraries to clients to use the service, think about it carefully, because it’s best to avoid repeating the integration code. If this mistake is made, it can also restrict changes being made in the API if the clients rely on unnecessary details.</p>

<h3 id="3-仔细设计各个服务"><strong>3. 仔细设计各个服务</strong></h3>

<p>设计服务时，要仔细的定义他们，并思考将公开的内容，服务间将使用什么协议来交互等。</p>

<p>隐藏服务的任何复杂性和实现细节，仅暴露服务的客户端所需的内容非常重要。如果暴露了不必要的细节，则后期变更服务变得非常困难，因为将会有许多艰苦的工作来确定谁依赖于服务的各个部分。此外在能独立部署服务方面丧失很大的灵活性。</p>

<p>下图展示了一个设计微服务时的常见错误：</p>

<p>正如你在图中所见，这里我们有一个服务（服务1），需要通过该服务来存储所有信息。当创建需要同样数据的另外一个服务（服务2）时，我们直接从数据库访问该数据。</p>

<p>在某些情况下，这种方法似合合理且合乎逻辑-可能访问数据库中的数据或者向数据库写数据很容易。或者服务2所需的服务并不是现成可用的。</p>

<p>一旦采用了这种方案，在确定隐藏什么和不隐藏什么时立即失去控制。往后如果架构需要变更，这个改变的灵活性也失去了。因为你不知道谁正在使用数据库，变更是否会破坏服务2.</p>

<p>解决这个问题的替代方案如下：</p>

<p>服务 2 应该访问服务 1 并避免直接访问数据库，因此为可能需要的各种模式变更提供了极大的灵活性。只要确保公开的 APIs 测试通过，则会消除对系统其它部分的担忧。</p>

<p>如上所述，仔细选择服务间通信协议。例如，如果选择了 Java 的 RMI，则不仅使用 API 的用户被限制需要使用基于 JVM 的语言，而且此外协议本身非常脆弱，因为难以保持与 API 的向后兼容性。</p>

<p>最后，在向客户端提供客户端以使用该服务时，请仔细考虑，因为最好避免重复集成的代码。如果出现此错误，如果客户端依赖不必要的详细信息，这将限制 API 做变更。</p>

<h3 id="4-decentralize-things"><strong>4. Decentralize Things</strong></h3>

<p>There are organizations who have found success with microservices and have followed a model where the teams who build the services take care of everything related to that service. They are the ones who develop, deploy, maintain and support it. There are no separate support or maintenance teams.</p>

<p>Another way to achieve the same is to have an internal open source model. By taking this approach, the developer who needs changes in a service can check out the code, work on a feature, and submit a PR himself instead of waiting for the service owner to pickup and work on needed changes.</p>

<p>For this model to work properly, the proper technical documentation is needed along with setup instructions and guidance for each service so that it’s easy for anyone to pickup and work on the service.</p>

<p>Another hidden advantage of this approach is that it keeps developers laser focused on writing high quality code as they know that others will be looking at it.</p>

<p>There are also some architectural patterns which can help in decentralizing things. For example, you might have an architecture where the collection of services are communicating via a central message bus.</p>

<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g0wqz24xzuj30pn0fo758.jpg" alt="" /></p>

<p>This bus handles the routing of messages from different services. Message brokers like RabbitMQ are a good example.</p>

<p>What tends to happen over time is people start putting more and more logic into this central bus and it starts knowing more and more about your domain. As it becomes more intelligent, that can actually become a problem as it becomes difficult to make changes which require coordination across separate dedicated teams.</p>

<p>My general advice for those types of architectures would be to keep them relatively “dumb” and let them just handle the routing. Event based architectures seem to work quite well in those scenarios.</p>

<h3 id="4-分散事物"><strong>4. 分散事物</strong></h3>

<p>有些组织已经通过微服务取得了成功，并且遵循一种模型，即构建服务的团队负责与该服务相关的所有事务。他们是开发、部署、维护和支持它的人，没有单独的支持或维护团队。</p>

<p>实现相同目标的另一种方式是拥有内部开源模型。通过采用这种方案，需要变更服务的开发者可以检出代码，在上面开发功能，并自行提交 PR 而不是等待服务所有者提出并处理所需的变更。</p>

<p>要使此模型正常工作，需要提供适当的技术文档以及每项服务的安装说明和指导。以便让任何人都可以轻易地接收和处理服务。</p>

<p>这种方案的另一隐藏优势在于它让开发专注于编写高质量的代码，因为他们知道其他人会关注它。</p>

<p>还有其他的一些架构模式可以帮助分散事物，例如，你可能拥有一个体系结构，其中服务集合通过中央消息总线来通信。</p>

<p>该总线处理来自不同服务消息的路由。诸如 RabbitMQ 这样的消息代理就是不错的例子。</p>

<p>随着时间的推移，人们开始将越来越多的逻辑加入中央总线，它开始越来越了解你的领域。随着它变得更加智能化，这实际上可能变成一个问题，因为变得难以进行需要跨不同的专门团队进行协调的变更。</p>

<p>对这种类型的架构我的一般建议是保持它们相对“愚蠢”，让它们仅仅处理路由的事情。事件驱动的框架似乎更适合这种场景。</p>

<h3 id="5-deploy"><strong>5. Deploy</strong></h3>

<p>It’s important to write Consumer Driven Contracts for any API that is being depended upon. This is to ensure that new changes in that API don’t break your API.</p>

<p>In Consumer Driven Contracts, each consumer API captures their expectations of the provider in a separate contract. All of these contracts are shared with the provider so that they gain insight into the obligations they must fulfill for each individual client.</p>

<p>Consumer Driven Contracts must pass completely before being deployed and before any changes are made to the API. It also helps the provider to know what services are depending on it and how other services are depending on it.</p>

<p>When it comes to deploying independent microservices, there are two common models.</p>

<h3 id="multiple-microservices-per-operating-system"><strong>Multiple Microservices Per Operating System</strong></h3>

<p>First, <strong>multiple microservices per operating system</strong> can be deployed. With this model time is saved in automating certain things, for example, the host for each service does not have to be provisioned.</p>

<p>The downside of this approach is that it limits the ability to change and scale services independently. It also creates difficulty in managing dependencies. For instance, all the services on the same host will have to use same version of Java if they are written in Java. Further, these independent services can produce unwanted side effects for other running services which can be a very difficult problem to reproduce and solve.</p>

<h3 id="one-microservice-per-operating-system"><strong>One Microservice Per Operating System</strong></h3>

<p>Because of the above challenge, the second model, where <strong>one microservice per operating system</strong> is deployed, is the preferable choice.</p>

<p>With this model, the service is more isolated and hence it’s easier to manage dependencies and scale services independently. But you may ask yourself “Isn’t it expensive”? Well, not really.</p>

<p>The traditional solution for solving this problem is using Hypervisors whereby multiple virtual machines are provisioned on the same host. This solution approach can be cost inefficient as the hypervisor process itself is consuming some resources and, of course, the more VMs that are provisioned, the more resources will be consumed. And that’s where the container model gets good traction and is preferred. Docker is one implementation of that model.</p>

<h3 id="making-changes-to-existing-microservice-apis-while-in-production"><strong>Making Changes to Existing Microservice APIs While In Production</strong></h3>

<p>Another common problem typically faced with a microservices model is determining how to make changes in existing microservice APIs when others are using it in production. Making changes to the microservice API might break the microservice which is dependent on it.</p>

<p>There are different ways to solve this issue.</p>

<p>First, version your API and when changes are required for the API, deploy the new version of the API while still keeping the first version up. The dependent services can then be upgraded at their own pace to use the newer version. Once all of the dependent services are migrated to use the new version of the changed microservice, it can be brought down.</p>

<p>One problem with this approach is that it becomes difficult to maintain the various versions. Any new changes or bug fixes must be done in both the versions.</p>

<p>For this reason, an alternative approach can be considered in which another end point is implemented in the same service when changes are needed. Once the new end point is being fully utilized by all services, then the old end point can be deleted.</p>

<p>The distinct advantage to this approach is that it’s easier to maintain the service as there will always be only one version of the API running.</p>

<h3 id="5-部署"><strong>5. 部署</strong></h3>

<p>为任何依赖的 API 编写消费驱动的合约非常重要，这是为了确保该 API 中新的变更不会破坏你原来的 API。</p>

<p>在消费者驱动的合约中，每个消费者API在单独的合约中捕获他们对提供者的期望。所有这些合约都与提供商共享，以便他们深入了解他们必须为每个客户履行的义务。</p>

<p>消费者驱动的合约必须在部署之前以及在对API进行任何更改之前完全通过。它还可以帮助提供商了解依赖于它的服务以及其他服务的依赖性。</p>

<p>在部署独立的微服务时，有两种常见的模型。</p>

<h3 id="每个操作系统的多个微服务"><strong>每个操作系统的多个微服务</strong></h3>

<p>首先，可以部署<strong>每个操作系统</strong>的多个微服务。使用此模型可以节省自动执行某些操作的时间，例如，不必配置每个服务的主机。</p>

<p>这种方法的缺点是它限制了独立改变和扩展服务的能力。它还会在管理依赖项方面造成困难。例如，如果使用Java编写，则同一主机上的所有服务都必须使用相同版本的Java。此外，这些独立服务可能会对其他运行服务产生不必要的副作用，这可能是一个非常难以复制和解决的问题。</p>

<h3 id="每个操作系统一个微服务"><strong>每个操作系统一个微服务</strong></h3>

<p>由于上述挑战，第二个模型，其中<strong>部署了每个操作系统</strong>一个微服务，是最好的选择。</p>

<p>使用此模型，服务更加孤立，因此更容易管理依赖关系并独立扩展服务。但你可能会问自己“这不是很贵”吗？好吧，不是真的。</p>

<p>解决此问题的传统解决方案是使用Hypervisors，在同一主机上配置多个虚拟机。这种解决方案方法成本效率低，因为虚拟机管理程序进程本身正在消耗一些资源，当然，配置的虚拟机越多，消耗的资源就越多。这就是容器模型获得良好牵引力的地方，也是首选。 Docker是该模型的一个实现。</p>

<h3 id="在生产中对现有微服务api进行更改"><strong>在生产中对现有微服务API进行更改</strong></h3>

<p>微服务模型通常面临的另一个常见问题是当其他人在生产中使用它时，确定如何对现有的微服务API进行更改。对微服务API进行更改可能会破坏依赖于它的微服务。</p>

<p>有不同的方法来解决这个问题。</p>

<p>首先，对API进行版本控制，并在API需要更改时，部署新版本的API，同时保持第一个版本。然后可以按照自己的进度升级从属服务以使用较新的版本。一旦迁移了所有依赖服务以使用更新的微服务的新版本，就可以将其降低。</p>

<p>这种方法的一个问题是难以维护各种版本。必须在两个版本中完成任何新的更改或错误修复。</p>

<p>出于这个原因，可以考虑另一种方法，其中在需要改变时在同一服务中实现另一个端点。一旦所有服务充分利用了新的终点，就可以删除旧的终点。</p>

<p>这种方法的独特优势在于维护服务更容易，因为始终只有一个版本的API在运行。</p>

<h3 id="6-making-standards"><strong>6. Making Standards</strong></h3>

<p>When there are multiple teams taking care of different services independently, it’s best to introduce some standards and best practices — error handling, for example. As might be expected, standards and best practices are not provided, each service would likely handle errors differently, and no doubt a significant amount of unnecessary code would be written.</p>

<p>Creating standards such as <a href="https://github.com/paypal/api-standards/blob/master/api-style-guide.md">PayPal’s API Style Guide</a> is always helpful in long run. It’s also important to let others know what an API does and documentation of the API should always be done when creating it. There are tools like <a href="https://swagger.io/">Swagger</a> which are very helpful in assisting in development across the entire API lifecycle, from design and documentation, to test and deployment. An ability to create metadata for your API and let users play with it, allows them to know more about it and use it more effectively.</p>

<h3 id="service-dependencies"><strong>Service Dependencies</strong></h3>

<p>In a microservices architecture, over time, each service starts depending on more and more services. This can introduce more problems as the services grow, for example, the number of service instances and their locations (host+port) might change dynamically. Also, the protocols and the format in which data is shared might vary from service to service.</p>

<p>Here’s where API Gateways and Service Discovery become very helpful. Implementing an API Gateway becomes a single entry point for all clients, and API Gateways can expose a different API for each client.</p>

<p>The API gateway might also implement security such as verifying that the client is authorized to perform the request. There are some tools like Zookeeper which can be used for Service Discovery (although it was not built for that purpose). There are much more modern tools like <a href="https://github.com/coreos/etcd">etcd</a> and Hashicorp’s <a href="https://www.consul.io/">Consul</a> which treat Service Discovery as a first class citizen and they are definitely worth looking at for this problem.</p>

<h3 id="6-制作标准"><strong>6. 制作标准</strong></h3>

<p>当多个团队独立维护多个不同的服务，最好是提出一些标准和最佳实践-例如错误处理。正如所料的那样，没有提供标准和最佳实践，每个服务可能用不同的方式处理错误，毫无疑问这将编写大量不必要的代码。</p>

<p>创建标准比如 <a href="https://github.com/paypal/api-standards/blob/master/api-style-guide.md">PayPal 的 API 类型指南</a> 等标准总是有帮助的。让其他人知道这个 API 的作用，以及创建 API 时始终完成相应的文档也很重要。有些类似 <a href="https://swagger.io/">Swagger</a> 的工具在整个API生命周期中协助开发中很有帮助，从设计和文档到测试和部署。为你的 API 创建元数据，并让用户使用它的能力，让他们更了解它，帮助他们更高效的使用。</p>

<h3 id="服务依赖"><strong>服务依赖</strong></h3>

<p>微服务架构中，随着时间的推移，每个服务开始依赖越来越多的服务。随着服务的增长这将引出更多的问题，例如，服务实例数以及他们的位置（Host+Port）可能是动态变化的。同时服务间协议和数据共享的协议可能因服务而异。</p>

<p>这就是 API 网关和服务发现变得非常有用的地方。实现一个 API 网关变成所有客户端的单一入口点。并且 API 网关可以为每个客户端导出不一样的 API。</p>

<p>API 网关还可以实现安全性，例如验证客户端是否有权执行请求。有一些像 Zookeeper 这样的工具可以用来做服务发现（虽然他可能不是为此目的而构建的）。有很多更现代的工具比如  <a href="https://github.com/coreos/etcd">etcd</a> and Hashicorp 的 <a href="https://www.consul.io/">Consul</a> 它们将服务发现作为第一类公民来对待，对于这个问题，它们绝对值得研究。</p>

<h3 id="7-failure"><strong>7. Failure</strong></h3>

<p>An important point to understand is that microservices aren’t resilient by default. There will be failures in services. Failures can happen because of failures in dependent services. Additionally, failures can arise for a variety of reasons such as bugs in code, network time outs, etc.</p>

<p>What’s critical with a microservices architecture is to ensure that the whole system is not impacted or goes down when there are errors in an individual part of the system.</p>

<p>There are patterns like Bulkhead and Circuits Breaker which can help you achieve better resilency.</p>

<h3 id="bulkhead"><strong>Bulkhead</strong></h3>

<p>The Bulkhead pattern isolates elements of an application into pools so that if one fails, the others will continue to function. The pattern is coined Bulkhead because it resembles the sectioned partitions of a ship’s hull. If the hull of a ship is compromised, only the damaged section fills with water, which prevents the ship from sinking.</p>

<h3 id="circuit-breaker"><strong>Circuit Breaker</strong></h3>

<p>The Circuit Breaker pattern wraps a protected function call in a circuit breaker object, which monitors for failures. Once a failure crosses the threshold, the circuit breaker trips, and all further calls to the circuit breaker return with an error, without the protected call being made at all for a certain configured timeout.</p>

<p>After the timeout expires some calls are allowed by circuit breaker to pass through, and if they succeed the circuit breaker resumes a normal state. For the period the circuit breaker has failed, users can be notified that a certain part of system is broken and the rest of the system can still be used.</p>

<p>Be aware that providing the required level of resiliency for an application can be a multi-dimensional challenge — take a look at Bilgin Ibryam’s post for some great detail “<a href="https://developers.redhat.com/blog/2017/05/16/it-takes-more-than-a-circuit-breaker-to-create-a-resilient-application/">It takes more than a Circuit Breaker to create a resilient application</a>”.</p>

<h3 id="7-失败"><strong>7. 失败</strong></h3>

<p>需要了解的一点是，微服务默认情况下不具备弹性。服务会出现故障。由于依赖服务的失败，可能会发生故障。此外，由于各种原因引起失败，比如代码 bug，网络超时等。</p>

<p>微服务架构的关键在于确保整个系统在系统的各个部分出现错误时，不会受到影响或出现故障。</p>

<p>有类似隔离和熔断器这样的模式来帮助你实现更好的容灾性。</p>

<h3 id="隔离"><strong>隔离</strong></h3>

<p>隔离模式将应用的实例隔离进池子，这样如果一个失败，其它实例可以继续服务。这个模式被命名为隔离模式，因为它类似船体的分段分区。如果船体受损，仅仅损坏的部分会充满水，这可以避免船沉没。</p>

<h3 id="断路器"><strong>断路器</strong></h3>

<p>断路器模式将受保护的函数调用包装进监控失败的断路器对象。当失败次数达到阈值，断路器跳闸，接下来所有对断路器的调用将返回错误，根本不需要为受保护的调用配置超时。</p>

<p>在超时到期后一些调用被断路器放过，如果它们返回成功则断路器将被恢复正常状态。断路器失败期间，可以通知用户系统的某个部分损坏，系统的其余部分仍然可用。</p>

<p>请注意，为应用程序提供所需的弹性级别可能是一个多维度的挑战-看看Bilgin Ibryam的帖子，了解更多细节 “<a href="https://developers.redhat.com/blog/2017/05/16/it-takes-more-than-a-circuit-breaker-to-create-a-resilient-application/">It takes more than a Circuit Breaker to create a resilient application</a>”。</p>

<h3 id="8-monitoring-and-logging"><strong>8. Monitoring and Logging</strong></h3>

<p>Microservices are distributed by nature and monitoring and logging of individual services can be a challenge. It’s difficult to go through and correlate logs of each service instance and figure out individual errors. Just as with monolithic applications, there is no single place to monitor microservices.</p>

<h3 id="log-aggregation"><strong>Log Aggregation</strong></h3>

<p>To solve such problems, a preferred approach is to take advantage of a centralized logging service that aggregate logs from each service instance. Users can search through these logs from one centralized spot and configure alerts when certain messages appear.</p>

<p>Standard tools are available and widely used by various enterprises. <a href="https://www.elastic.co/elk-stack">ELK Stack</a> is the most frequently used solution, where logging daemon, <a href="https://www.elastic.co/products/logstash">Logstash</a>, collects and aggregate logs which can be searched via a Kibana dashboard indexed by Elasticsearch.</p>

<h3 id="stats-aggregation"><strong>Stats Aggregation</strong></h3>

<p>Similar to log aggregation, stats aggregation such as CPU and memory usage can also be leveraged and stored centrally. Tools such as Graphite do a nice job in pushing to a central repository and storing in an efficient way.</p>

<p>When one of the downstream services is incapable of handling requests, there should be a way to trigger an alert, and that’s where implementing health check APIs in each service become important — they return information on the health of the system.</p>

<p>A health check client, which could be a monitoring service or a load balancer, invokes the endpoint to check the health of the service instance periodically in a certain time interval. Even if all of the downstream services are healthy, there could still be a downstream communication problem between services. Tools such as <a href="https://github.com/Netflix/Hystrix">Netflix’s Hystrix</a> project enable an ability to identify those types of problems.</p>

<h3 id="8-监控和日志"><strong>8. 监控和日志</strong></h3>

<p>微服务本质上是分布式的，并且对各个服务进行监控和日志记录可能是一个挑战。很难通过浏览和关联每个服务实例的日志并找出任意的错误。就像单体应用一样，没有一个地方可以监控微服务。</p>

<h3 id="日志聚合"><strong>日志聚合</strong></h3>

<p>解决这些问题，首选的方案是利用集中的日志服务来聚合每个服务实例的日志。用户可以在一个集中的地方检索他们的日志，并在出现某些消息时配置告警。</p>

<p>很多可用的标准的工具被很多企业广泛使用。<a href="https://www.elastic.co/elk-stack">ELK 技术栈</a> 是最广泛使用的方案，日志守护进程， <a href="https://www.elastic.co/products/logstash">Logstash</a>,收集与聚合日志，可以通过 Elasticsearch 索引的 Kibana 控制台进行搜索。</p>

<h3 id="统计聚合"><strong>统计聚合</strong></h3>

<p>与日志聚合类似，也可以集中利用和存储统计聚信息聚合诸如 CPU 和内存使用情况。像 Graphite 这样的工具在向集中仓库高效推送和存储方面做得不错。</p>

<p>当其中一个下游服务不能处理请求时，应该有一种触发告警的方法，这也就是为什么在每个服务实现健康检查 API 变得如此重要-它们返回有关系统健康状况的信息。</p>

<p>健康检查客户端可以是监控服务或者负载均衡器，在某个时间间隔定期调用节点来检查服务的健康状况。即使所有下游服务都是健康的，下游服务间的通信仍然可能出问题。像 <a href="https://github.com/Netflix/Hystrix">Netflix’s Hystrix</a> 项目这样的工具提供了定位此类问题的能力。</p>

<h3 id="one-last-thing"><strong>One Last Thing</strong></h3>

<p>Now that we have covered what a microservices architecture is, why you’d want to deploy a microservices architecture, and thoughts on getting started, I’d like to offer up a final piece of advice:</p>

<blockquote>
<p>— Start Small —</p>
</blockquote>

<p>When you are just starting to develop microservices, start modestly with just one or two services, learn from them, and with time and experience add more.</p>

<p>I wish you the best of success as you travel down this exciting microservices architecture path.</p>

<h3 id="最后一点"><strong>最后一点</strong></h3>

<p>我们已经介绍了什么是微服务架构，为什么你应该想部署微服务架构和一些开始微服务架构的思路。我想最后给点建议：</p>

<blockquote>
<p>— 小处着眼 —</p>
</blockquote>

<p>如果你刚刚开始开发微服务，从一个两个服务适度的开始，从中学习，随着时间的推移获取更多的经验。</p>

<p>在您踏上这条激动人心的微服务体系结构之路时，我祝您取得最大的成功。</p>

</div>

  
<footer class='entry-footer'>
  <div class='container sep-before'><div class='categories'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <path d="M22,19a2,2,0,0,1-2,2H4a2,2,0,0,1-2-2V5A2,2,0,0,1,4,3H9l2,3h9a2,2,0,0,1,2,2Z"/>
  
</svg>
<span class='screen-reader-text'>Categories: </span><a class='category' href='https://idevz.github.io/categories/%E6%8A%80%E6%9C%AF/'>技术</a>, <a class='category' href='https://idevz.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/'>微服务</a></div>
<div class='tags'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <path d="M20.59,13.41l-7.17,7.17a2,2,0,0,1-2.83,0L2,12V2H12l8.59,8.59A2,2,0,0,1,20.59,13.41Z"/>
  <line x1="7" y1="7" x2="7" y2="7"/>
  
</svg>
<span class='screen-reader-text'>Tags: </span><a class='tag' href='https://idevz.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/'>微服务</a>, <a class='tag' href='https://idevz.github.io/tags/architecture/'>Architecture</a></div>

  </div>
</footer>


</article>

<nav class='entry-nav'>
  <div class='container'><div class='prev-entry sep-before'>
      <a href='https://idevz.github.io/2017/12/%E4%BD%BF%E7%94%A8vs-code-%E8%B0%83%E8%AF%95-golang-%E7%A8%8B%E5%BA%8F/'>
        <span aria-hidden='true'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <line x1="20" y1="12" x2="4" y2="12"/>
  <polyline points="10 18 4 12 10 6"/>
  
</svg>
 Previous</span>
        <span class='screen-reader-text'>Previous post: </span>使用Vs Code 调试 Golang 程序</a>
    </div><div class='next-entry sep-before'>
      <a href='https://idevz.github.io/2018/11/service-mesh-%E4%B8%80%E7%A7%8D%E6%96%B0%E7%9A%84%E6%A8%A1%E5%BC%8F%E8%80%8C%E4%B8%8D%E6%98%AF%E6%96%B0%E6%8A%80%E6%9C%AF/'>
        <span class='screen-reader-text'>Next post: </span>Service mesh — 一种新的模式而不是新技术<span aria-hidden='true'>Next <svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <line x1="4" y1="12" x2="20" y2="12"/>
  <polyline points="14 6 20 12 14 18"/>
  
</svg>
</span>
      </a>
    </div></div>
</nav>




      </main>

      <footer id='footer' class='footer'>
        <div class='container sep-before'><div class='copyright'>
  <p>© 2020 idevz.org</p>
</div>

        </div>
      </footer>

    </div>
  </div><script>window.__assets_js_src="https://idevz.github.io/assets/js/"</script>

<script src='https://idevz.github.io/assets/js/main.67d669ac.js'></script>

</body>

</html>

