<!DOCTYPE html>
<html lang='en'><head>
  <meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='description' content='原著信息： Service Mesh – A New Pattern, Not A New Technology?
by:Marco Palladino
What is Service Mesh and Where Did it Come From? Over the past few months, you may have noticed the explosion of industry chatter and articles surrounding service mesh and the future of software architecture. These discussions have been highly polarizing, with tribes forming around specific vendors. While this partisan trend is to be expected, the common thread among these discussions is the rapid transformation of how APIs are used in the enterprise, and what this means for the topology of our traffic.'>
<meta name='theme-color' content='#ffcd00'>

<meta property='og:title' content='Service mesh — 一种新的模式而不是新技术 • 做一个善于思考的学习者'>
<meta property='og:description' content='原著信息： Service Mesh – A New Pattern, Not A New Technology?
by:Marco Palladino
What is Service Mesh and Where Did it Come From? Over the past few months, you may have noticed the explosion of industry chatter and articles surrounding service mesh and the future of software architecture. These discussions have been highly polarizing, with tribes forming around specific vendors. While this partisan trend is to be expected, the common thread among these discussions is the rapid transformation of how APIs are used in the enterprise, and what this means for the topology of our traffic.'>
<meta property='og:url' content='https://idevz.github.io/2018/11/service-mesh-%E4%B8%80%E7%A7%8D%E6%96%B0%E7%9A%84%E6%A8%A1%E5%BC%8F%E8%80%8C%E4%B8%8D%E6%98%AF%E6%96%B0%E6%8A%80%E6%9C%AF/'>
<meta property='og:site_name' content='做一个善于思考的学习者'>
<meta property='og:type' content='article'><meta property='article:section' content='tech'><meta property='article:tag' content='ServiceMesh'><meta property='article:published_time' content='2018-11-13T22:11:56&#43;08:00'/><meta property='article:modified_time' content='2019-04-08T22:05:43&#43;08:00'/><meta name='twitter:card' content='summary'>

<meta name="generator" content="Hugo 0.60.0-DEV" />

  <title>Service mesh — 一种新的模式而不是新技术 • 做一个善于思考的学习者</title>
  <link rel='canonical' href='https://idevz.github.io/2018/11/service-mesh-%E4%B8%80%E7%A7%8D%E6%96%B0%E7%9A%84%E6%A8%A1%E5%BC%8F%E8%80%8C%E4%B8%8D%E6%98%AF%E6%96%B0%E6%8A%80%E6%9C%AF/'>
  
  
  <link rel='icon' href='https://idevz.github.io/favicon.ico'>
<link rel='stylesheet' href='https://idevz.github.io/assets/css/main.6a060eb7.css'><style>
:root{--color-accent:#ffcd00;}
</style>

<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-71947507-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  

</head><body class='page type-tech'>

  <div class='site'><a class='screen-reader-text' href='#content'>Skip to Content</a><div class='main'><nav id='main-menu' class='menu main-menu' aria-label='Main Menu'>
  <div class='container'>
    
    <ul><li class='item'>
        <a href='https://idevz.github.io/'>idevz.org</a>
      </li><li class='item'>
        <a href='https://idevz.github.io/tech/'>技术</a>
      </li><li class='item'>
        <a href='https://idevz.github.io/tools/'>工具</a>
      </li><li class='item'>
        <a href='https://idevz.github.io/life/'>Life</a>
      </li><li class='item'>
        <a href='https://idevz.github.io/page/about/'>关于</a>
      </li></ul>
  </div>
</nav><div class='header-widgets'>
        <div class='container'></div>
      </div>

      <header id='header' class='header site-header'>
        <div class='container sep-after'>
          <div class='header-info'><p class='site-title title'>做一个善于思考的学习者</p><p class='desc site-desc'>Every Day Create Your History.</p>
          </div>
        </div>
      </header>

      <main id='content'>


<article lang='en' class='entry'>
  <header class='header entry-header'>
  <div class='container sep-after'>
    <div class='header-info'>
      <h1 class='title'>Service mesh — 一种新的模式而不是新技术</h1>
      

    </div>
    <div class='entry-meta'>
  <span class='posted-on'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"/>
  <line x1="16" y1="2" x2="16" y2="6"/>
  <line x1="8" y1="2" x2="8" y2="6"/>
  <line x1="3" y1="10" x2="21" y2="10"/>
  
</svg>
<span class='screen-reader-text'>Posted on </span>
  <time class='entry-date' datetime='2018-11-13T22:11:56&#43;08:00'>2018, Nov 13</time>
</span>

  
  
<span class='reading-time'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <circle cx="12" cy="12" r="10"/>
  <polyline points="12 6 12 12 15 15"/>
  
</svg>
6 mins read
</span>


</div>


  </div>
</header>

  
  
<details class='container entry-toc'>
  <summary class='title'>
    <span>Table of Contents</span>
  </summary>
  <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#what-is-service-mesh-and-where-did-it-come-from"><strong>What is Service Mesh and Where Did it Come From?</strong></a></li>
<li><a href="#什么是service-mesh以及它来自哪里"><strong>什么是Service Mesh以及它来自哪里？</strong></a></li>
<li><a href="#service-mesh-is-a-pattern-not-a-technology"><strong>Service Mesh is a Pattern, Not a Technology</strong></a></li>
<li><a href="#服务网格是一种模式-而不是一种技术"><strong>服务网格是一种模式，而不是一种技术</strong></a></li>
<li><a href="#traditional-api-management-solutions-can-t-keep-up"><strong>Traditional API Management Solutions Can’t Keep Up</strong></a></li>
<li><a href="#conclusion"><strong>Conclusion</strong></a></li>
<li><a href="#结论"><strong>结论</strong></a></li>
</ul></li>
</ul>
</nav>
</details>


  <div class='container entry-content'>
  

<p><strong>原著信息：</strong>
<a href="https://konghq.com/blog/service-mesh-new-pattern-not-new-technology/">Service Mesh – A New Pattern, Not A New Technology?</a></p>

<p><strong>by:</strong><a href="https://konghq.com/blog/author/marco/">Marco Palladino</a></p>

<h2 id="what-is-service-mesh-and-where-did-it-come-from"><strong>What is Service Mesh and Where Did it Come From?</strong></h2>

<p>Over the past few months, you may have noticed the explosion of industry chatter and articles surrounding service mesh and the future of software architecture. These discussions have been highly polarizing, with tribes forming around specific vendors. While this partisan trend is to be expected, the common thread among these discussions is the <strong>rapid transformation of how APIs are used in the enterprise</strong>, and what this means for the topology of our traffic.</p>

<p>In a short period of time, service APIs went from being primarily an edge interface connecting developers outside of the organization with internal systems to the <strong>glue that binds those internal systems (microservices) into a functioning whole</strong>. Consequently, one of the unavoidable results of microservice-oriented architectures is that internal<strong>communication within the data center</strong> <strong>will increase</strong>. Service mesh arose as a potential solution to the <strong>challenges that arise from increased East-West traffic</strong> by providing a different framework for deploying existing technology.</p>

<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g0xssx9p8nj30ma0dr747.jpg" alt="" /></p>

<p>As CTO of Kong, and an active participant in these conversations, I have noticed a common misconception about what service mesh is. In the hope of dispelling confusion and advancing discussions, I want to unequivocally state the following: <strong>service mesh is a pattern, not a technology</strong>.</p>

<h2 id="什么是service-mesh以及它来自哪里"><strong>什么是Service Mesh以及它来自哪里？</strong></h2>

<p>在过去几个月，你可能已经注意到围绕着 Service Mesh 和未来软件架构激烈的行业争论和文章。这些讨论围绕特定供应商形成高度分化。虽然这种趋势是可以预料到的，但在这些讨论中，一个共同的主题是<strong>如何在企业中使用API的快速转换</strong>，以及这对我们的流量拓扑意味着什么。</p>

<p>在很短的一段时间，服务 API 从最初的将组织外部的开发人员与内部系统连接起来的边缘接口，转变为将这些内部系统(微服务)绑定为一个功能完整的<strong>的粘合剂</strong>。因此，面向微服务的体系结构的一个不可避免的结果是数据中心内的<strong>通信将增加</strong>。通过为部署现有技术提供一个不同的框架，Service Mesh 作为一个潜在的解决方案出现了，<strong>解决了由于东西向流量增加而产生的挑战。</strong></p>

<p>作为 Kong 的首席技术官和这些对话的积极参与者，我注意到一个常见的关于 Service Mesh 是什么的误解。为了消除混淆推进讨论，我想明确指出以下几点：<strong>Service Mesh 是一种模式，而不是技术</strong>。</p>

<h2 id="service-mesh-is-a-pattern-not-a-technology"><strong>Service Mesh is a Pattern, Not a Technology</strong></h2>

<p>In the same way that microservices are a pattern and not a specific technology, so too is service mesh. Distinguishing between the two sounds more complex than it is in reality. If we think about this through the lens of Object Oriented Programming (OOP), a pattern describes the interface – not the implementation.</p>

<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g0xsthxf84j30ma0ah745.jpg" alt="" /></p>

<p>In the context of microservices, the service mesh deployment pattern becomes advantageous due to its ability to better manage East-West traffic via sidecar proxies. As we are decoupling our monoliths and building new products with microservices, the topology of our traffic is also changing from primarily external to increasingly internal. East-West traffic within our datacenter is growing because we are replacing function calls in the monolith with network calls, meaning our microservices must go on the network to consume each other. And the network – as we all know – is unreliable.</p>

<p>What service mesh seeks to address through use of a different deployment pattern are the challenges associated with increased East-West traffic. While with traditional N-S traffic 100ms of middleware processing latency was not ideal but may have been acceptable, in a microservice architecture with E-W traffic it can no longer be tolerated. The reason for this is that the increased east-west traffic between services will compound that latency, resulting in perhaps 700ms of latency by the time the chain of API requests across different services has been executed and returned.</p>

<p>In an effort to reduce this latency, sidecar proxies running alongside a microservice process are being introduced to remove an extra hop in the network. Sidecar proxies, which correspond to data planes on the execution path of our requests, also provide better resiliency since we don’t have a single point of failure anymore. However, sidecar proxies bear the cost of having an instance of our proxy for every instance of our microservices, which necessitates a small footprint in order to minimize resource depletion.</p>

<p>From a feature perspective, however, most of what service mesh introduces has been provided for many years by API Management products. Features such as observability, network error handling, health-checks, etc. are hallmarks of API management. These features don’t constitute anything novel in themselves, but as a pattern, service mesh introduces a new way of deploying those features within our architecture.</p>

<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g0xsts3i20j30mh0a7wec.jpg" alt="" /></p>

<h2 id="服务网格是一种模式-而不是一种技术"><strong>服务网格是一种模式，而不是一种技术</strong></h2>

<p>与微服务是一种模式而不是特定技术的方式相同，Service Mesh 也是如此。区分这两者听起来比实际上要复杂得多。如果我们通过面向对象编程（OOP）的视角来思考这个问题，一个模式描述了接口 - 而不是实现。</p>

<p>在微服务上下文中，服务网格部署模式由于能够通过 Sidecar 代理更好地管理东西向流量而变得非常有利。当我们正在解耦我们的单体服务并使用微服务构建新产品时，我们的流量拓扑结构也正在从主要的外部拓扑结构转变为越来越多的内部拓扑结构。我们数据中心内的东西向流量正在增长，因为我们正在用网络调用替换整体中的函数调用，这意味着我们的微服务必须在网络上相互使用。我们都知道，网络是不可靠的。</p>

<p>Service Mesh 试图通过使用不同的部署模式来解决与增加的东西向流量相关的挑战。虽然对于传统的N-S流量来说，100ms的中间件处理延迟并不理想，但是可以接受，但是对于具有E-W流量的微服务体系结构来说，这是不能再容忍的。这样做的原因是，服务之间东西向流量的增加将增加延迟，当跨不同服务的 API 请求链执行和返回时，可能会导致700ms的延迟。</p>

<p>为了减少这种延迟，引入了运行在微服务进程旁边的 Sidecar 代理，以去除网络中额外的一跳。 Sidecar 代理对应于请求执行路径上的数据平面，也提供了更好的弹性，因为我们不再有单点故障。然而，Sidecar 代理需要为微服务的每个实例都提供一个代理实例，这就需要占用很小的内存，以便将资源消耗降到最低。</p>

<p>然而，从功能的角度来看，Service Mesh 所引入的大部分内容都是 API 管理产品多年来提供的特性，如可观察性，网络错误处理，健康检查等都是API管理的标志。这些特性本身并不构成任何新特性，但是作为一种模式，Service Mesh 引入了一种在体系结构中部署这些特性的新方法。</p>

<h2 id="traditional-api-management-solutions-can-t-keep-up"><strong>Traditional API Management Solutions Can’t Keep Up</strong></h2>

<p>Microservices and containers force you to look at systems by prioritizing more lightweight processes, and service mesh as a pattern fills this need by providing a lightweight process that can act as both proxy and reverse proxy to run alongside the main microservice. Why won’t most traditional API Management solutions allow this new deployment option? Because they were born in a monolithic world.  As it turns out, API Management solutions built before the advent of Docker and Kubernetes were monoliths themselves and were not designed to work effectively within the emerging container ecosystem. The heavyweight runtimes and slower performance offered by traditional API management solutions were acceptable in the traditional API-at-the-edge use case, but are not in a microservices architecture where latency compounds over time via increased east-west traffic activity. In essence, traditional API management solutions are ultimately too heavyweight, too hard to automate, and too slow to effectively broker the increased communication inherent with microservices.</p>

<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g0xs5jdaiij30tq0e5glk.jpg" alt="" /></p>

<p>Since developers understand this, legacy API Management solutions born before the advent of containers have introduced what they call “microgateways” to deal with E-W traffic and avoid rewriting their existing, bloated, monolith gateway solutions. The problem is, these microgateways – while being more lightweight – still require the legacy solution to run alongside them in order to execute policy enforcement. This doesn’t just mean keeping the same old heavy dependency in the stack, it also means increased latency between every request. It’s understandable then why service mesh feels like a whole new category. It’s not because it’s new, but rather because the API Management solutions of yesterday are incapable of supporting it.</p>

<p>###<strong>传统的API管理解决方案已经跟不上了</strong></p>

<p>微服务和容器通过优先处理更轻量级的进程，迫使你查看系统，而 Service Mesh 作为一种模式，通过提供一个可以同时充当代理和反向代理的轻量级进程来满足这种需求，与主微服务一起运行。为什么大多数传统的 API 管理解决方案不允许这个新的部署选项?因为他们出生在一个单体服务的世界。其实，API 管理方案在 Docker 和 Kubernetes 和单体应用本身之前就出现了，它并不是为了在新兴的容器生态系统中有效地工作而设计的。传统 API 管理方案提供的重量级的运行时和低性能在传统的 API-at-the-edge 用例中是可以接受的，但在微服务体系结构中，随着时间的推移延迟会随着东西向流量的增加而加剧。本质上传统 API 管理方案因为根本上太重，太难以自动化，而且速度太慢，无法有效地协调与微服务之间不断增加的通信。</p>

<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g0xs5jdaiij30tq0e5glk.jpg" alt="" /></p>

<p>因为开发者明白遗留的 API 管理方案在容器出现前就已经存在，他们引入了所谓的“微网关”来处理东西向流量，并且避免重写他们已有的、臃肿的单体网关方案。问题是，这些微网关-虽然变得更轻量-仍然需要遗留解决方案与它们一起运行，以便执行强制策略。这不仅意味着在技术栈上保持老重的依赖，同时意味着每次请求增加的延迟。这就不难理解为什么服务网格会给人一种全新的感觉。不是因为它新，而是因为过去的 API 管理方案不能支持它。</p>

<h2 id="conclusion"><strong>Conclusion</strong></h2>

<p>When you look at service mesh in the context of its feature-set, it becomes clear that it’s not very different from what traditional API Management solutions have been doing for years for N-S traffic. Most of the networking and observability capabilities are useful in both N-S and E-W traffic use-case has changed is the deployment pattern, which enables us to run the gateway/proxy as a lightweight, fast sidecar container, but not the underlying feature-set.</p>

<p>The feature-set that a service mesh provides is a subset of the feature-set that API Management solutions have been offering for many years, in particular when it comes to making the network reliable, service discovery and observability. The innovation of service mesh is its deployment pattern, which enables to run that same feature-set as a lightweight sidecar process/container. Too often our industry confuses – and sometimes pushes – the idea that a specific pattern equals the underlying technology, as in the case of many conversations around service mesh.</p>

<h2 id="结论"><strong>结论</strong></h2>

<p>当你从 Service Mesh 的功能集这个上下文来看它时，就变得很清晰。它与传统的 API 管理方案已经处理了多年的南北向流量并没有太多不同。大多数网络和可见性功能在南北向和东西向都同样有用，用例改变其部署模式，这使得我们以轻量、快速的 Sidercar 容器来运行网关 / 代理，而不是底层的功能集合。</p>

<p>Service Mesh 所提供的功能集是 API 管理方案已经提供了多年功能子集。特别是在使网络可靠、服务发现和可观察性方面。Service Mesh 创新的是其部署模式，使得以一个轻量的 Sidercar 进程 / 容器运行相同的功能集合。我们的行业经常混淆-有时推广-一个特定的模式等同于底层的技术，围绕着 Service Mesh 的众多讨论就是这样的。</p>

</div>

  
<footer class='entry-footer'>
  <div class='container sep-before'><div class='categories'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <path d="M22,19a2,2,0,0,1-2,2H4a2,2,0,0,1-2-2V5A2,2,0,0,1,4,3H9l2,3h9a2,2,0,0,1,2,2Z"/>
  
</svg>
<span class='screen-reader-text'>Categories: </span><a class='category' href='https://idevz.github.io/categories/%E6%8A%80%E6%9C%AF/'>技术</a>, <a class='category' href='https://idevz.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/'>微服务</a>, <a class='category' href='https://idevz.github.io/categories/servicemesh/'>ServiceMesh</a></div>
<div class='tags'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <path d="M20.59,13.41l-7.17,7.17a2,2,0,0,1-2.83,0L2,12V2H12l8.59,8.59A2,2,0,0,1,20.59,13.41Z"/>
  <line x1="7" y1="7" x2="7" y2="7"/>
  
</svg>
<span class='screen-reader-text'>Tags: </span><a class='tag' href='https://idevz.github.io/tags/servicemesh/'>ServiceMesh</a></div>

  </div>
</footer>


</article>

<nav class='entry-nav'>
  <div class='container'><div class='prev-entry sep-before'>
      <a href='https://idevz.github.io/2018/09/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9A%84-whatwhy%E5%92%8C-how/'>
        <span aria-hidden='true'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <line x1="20" y1="12" x2="4" y2="12"/>
  <polyline points="10 18 4 12 10 6"/>
  
</svg>
 Previous</span>
        <span class='screen-reader-text'>Previous post: </span>微服务架构的 What，Why，和 How</a>
    </div><div class='next-entry sep-before'>
      <a href='https://idevz.github.io/2018/12/tour-of-go/'>
        <span class='screen-reader-text'>Next post: </span>Tour of Go<span aria-hidden='true'>Next <svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <line x1="4" y1="12" x2="20" y2="12"/>
  <polyline points="14 6 20 12 14 18"/>
  
</svg>
</span>
      </a>
    </div></div>
</nav>




      </main>

      <footer id='footer' class='footer'>
        <div class='container sep-before'><div class='copyright'>
  <p>© 2020 idevz.org</p>
</div>

        </div>
      </footer>

    </div>
  </div><script>window.__assets_js_src="https://idevz.github.io/assets/js/"</script>

<script src='https://idevz.github.io/assets/js/main.67d669ac.js'></script>

</body>

</html>

